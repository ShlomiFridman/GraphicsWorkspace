!SESSION 2024-09-25 08:56:29.816 -----------------------------------------------
eclipse.buildId=4.28.0.20230608-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file D:\My_Documents\OneDrive - ORT Braude College of Engineering\DOK\Graphics\workspace\.metadata\.bak_0.log
Created Time: 2024-09-25 11:23:57.879

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:23:57.879
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:23:57.881
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:23:58.577
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix4f modelviewM = new Matrix4f().identity();
			Matrix4f projectionM = new Matrix4f().identity();
			private Matrix4f viewportM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:23:58.615
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:23:58.616
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:23:59.093
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix4f modelviewM = new Matrix4f().identity();
			Matrix4f projectionM = new Matrix4f().identity();
			Matrix4f viewportM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:23:59.104
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:23:59.106
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:23:59.987
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix4f modelviewM = new Matrix4f().identity();
			Matrix4f projectionM = new Matrix4f().identity();
			Matrix4f viewportM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:23:59.988
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:23:59.989
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:24:01.845
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix4f modelviewM = new Matrix4f().identity();
			Matrix4f projectionM = new Matrix4f().identity();
			Matrix4f viewportM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:24:01.845
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:24:01.846
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:24:02.888
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			Matrix4f projectionM = new Matrix4f().identity();
			Matrix4f viewportM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:24:02.889
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:24:02.890
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:24:02.998
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			Matrix4f projectionM = new Matrix4f().identity();
			Matrix4f viewportM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:24:03.005
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:24:03.005
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:24:04.151
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			Matrix4f projectionM = new Matrix4f().identity();
			Matrix4f viewportM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:24:04.152
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:24:04.152
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:24:05.122
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			Matrix3f projectionM = new Matrix4f().identity();
			Matrix4f viewportM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:24:05.123
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:24:05.124
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:24:05.236
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			Matrix3f projectionM = new Matrix4f().identity();
			Matrix4f viewportM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:24:05.237
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:24:05.237
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:24:06.651
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			Matrix3f projectionM = new Matrix4f().identity();
			Matrix4f viewportM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:24:06.651
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:24:06.652
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:24:10.380
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			Matrix3f projectionM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:24:10.381
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:24:10.382
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:24:10.495
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			Matrix3f projectionM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:24:10.496
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:24:10.497
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:24:11.752
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			Matrix3f projectionM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:24:11.753
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:24:11.754
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:24:12.827
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			Matrix3f projectionM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:24:12.828
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:24:12.829
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:25:33.634
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			Matrix3f projectionM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:25:33.657
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:25:33.658
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:25:34.313
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			Matrix3f projectionM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:25:34.314
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:25:34.315
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:25:35.057
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:25:35.058
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:25:35.075
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:25:35.201
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:25:35.202
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:25:35.203
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:25:41.678
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:25:41.687
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:25:41.688
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:25:44.790
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:25:44.791
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:25:44.792
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:25:46.357
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:25:46.358
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:25:46.359
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:25:50.040
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:25:50.041
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:25:50.042
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:25:51.186
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:25:51.187
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:25:51.209
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:25:51.343
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:25:51.344
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:25:51.345
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:25:52.342
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewMץ
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:25:52.344
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:25:52.345
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:25:53.817
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:25:53.818
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:25:53.819
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:25:54.636
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM.
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:25:54.637
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:25:54.638
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:26:00.964
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:26:00.966
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:26:00.967
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:26:01.324
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:26:01.325
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:26:01.326
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:26:02.866
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:26:02.868
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:26:02.868
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:26:04.810
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:26:04.812
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:26:04.813
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:26:05.106
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:26:05.108
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:26:05.109
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:26:54.660
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:26:54.661
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:26:54.662
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:26:56.043
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:26:56.044
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:26:56.046
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:26:57.394
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:26:57.395
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:26:57.396
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:27:09.517
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:27:09.518
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:27:09.518
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:27:09.685
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:27:09.687
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:27:09.687
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:27:10.831
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:27:10.832
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:27:10.833
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:27:10.896
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1008)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:804)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:748)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:671)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:663)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:27:10.897
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1008)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:804)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:748)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:671)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:663)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:27:10.898
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1008)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:804)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:748)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:671)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:663)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:27:10.916
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:27:10.918
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:27:10.918
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:27:12.550
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:27:12.552
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:27:12.553
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:27:14.040
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:27:14.042
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:27:14.042
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:27:16.463
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:27:16.464
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:27:16.465
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:11.116
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
