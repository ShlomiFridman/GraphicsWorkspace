package your_code;

import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import org.joml.Matrix3f;
import org.joml.Vector3f;

import app_interface.ExerciseEnum;
import app_interface.Model;
import app_interface.ModelLight;
import app_interface.ModelMaterial;
import app_interface.ModelSphere;
import app_interface.SphereTexture;

//class holding the world model and render it
public class WorldModel {

	/** The Model object with all the details of the world model that will be rendered */
	Model model;

	/** Your selection enum type (specific to your implementation) */	
	private YourSelectionEnum yourSelection;

	/** The current exercise being executed (from ExerciseEnum) */	
	private static ExerciseEnum exercise = ExerciseEnum.EX_8___Transparency;

	/** image width and height in pixles*/
	private int imageWidth; 
	private int imageHeight;

	/** SphereTexture object of the skybox of the world model */
	SphereTexture skyBoxImageSphereTexture;

	/** The depth of ray tracing used during rendering */
	private static int depthOfRayTracing;
	
	private ErrorLogger errorLogger;

	public WorldModel(int imageWidth, int imageHeight, ErrorLogger errorLogger) {
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
		this.errorLogger = errorLogger;
		
		errorLogger.report(ErrorLogger.ErrorType.EXAMPLE_ERROR_1);
		errorLogger.report(ErrorLogger.ErrorType.EXAMPLE_ERROR_2);
		errorLogger.report(ErrorLogger.ErrorType.EXAMPLE_ERROR_1);
		errorLogger.report(ErrorLogger.ErrorType.EXAMPLE_ERROR_2);
	}

	public void setRenderingParams(int depthOfRayTracing) {
		WorldModel.depthOfRayTracing = depthOfRayTracing;
	}

	public void setExercise(ExerciseEnum exercise) {
		WorldModel.exercise = exercise;
	}

	public void setYourSelection(YourSelectionEnum sel) {
		this.yourSelection = sel;
	}

	/** Loads a model from a specified file 
	* @param fileName the path to the model file
	* @return true if the model was loaded successfully, false otherwise
	* @throws Exception if there is an error loading the model file	*/	
	public boolean load(String fileName) {
		try {
			model = new Model(fileName);
			skyBoxImageSphereTexture = new SphereTexture(model.skyBoxImageFileName);
			return true;
		} catch (Exception e) {
			//System.err.println("Failed to load the model file: " + fileName + ".\nDescription: " + e.getMessage());
			return false;
		}
	}

	/** Renders the color of a specific pixel in the image
	* @param x the x coordinate of the pixel
	* @param y the y coordinate of the pixel
	* @return the Vector3f representing the color of the pixel */	
	public Vector3f renderPixel(int x, int y) {
		if (exercise == ExerciseEnum.EX_0___Starting_point)
			return new Vector3f(0);
		else if (exercise == ExerciseEnum.EX_1_0_Colors_one_color) {
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution 1.0 ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
			return new Vector3f(1,1,0);
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//			return new Vector3f(0);			
////////////////////////////////////////////////////////////////////////////////////
		} else if (exercise == ExerciseEnum.EX_1_1_Colors_Random_color) {
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution 1.1 ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
			return new Vector3f((float) Math.random(),(float) Math.random(),(float) Math.random());
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//			return new Vector3f(0);			
////////////////////////////////////////////////////////////////////////////////////
		} else if (exercise == ExerciseEnum.EX_1_2_Colors_Color_space) {
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution 1.2 ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
			Matrix3f mat = new Matrix3f().set(-1.0f / (imageWidth - 1), -1.0f / (imageHeight - 1), 1.0f, // First row
											  1.0f / (imageWidth - 1), 0.0f, 0.0f, // Second row
											  0.0f, 1.0f / (imageHeight - 1), 0.0f // Third row
										  ).transpose();
			return mat.transform(new Vector3f(x, y, 1));
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//return new Vector3f(0);			
////////////////////////////////////////////////////////////////////////////////////
		} else if (exercise == ExerciseEnum.EX_1_3_Colors_linear) {
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution 1.3 ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
			Vector3f c1 = new Vector3f(1, 0, 0);
			Vector3f c2 = new Vector3f(0, 1, 0);
			Vector3f c =         new Vector3f(c1).mul((float)(imageWidth-1-x)/(imageWidth-1))
					     .add(
					    		 new Vector3f(c2).mul((float)(x)/(imageWidth-1)));
			return c;
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//return new Vector3f(0);			
////////////////////////////////////////////////////////////////////////////////////
		} else {
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
			// Set up the camera position (at origin)
			Vector3f cameraPosition = new Vector3f(0.0f, 0.0f, 0.0f);
			// calculate pixel direction
			Vector3f pixelRayDirection = calcPixelDirection(x, y, imageWidth, imageHeight, model.fovXdegree);
			return rayTracing(cameraPosition, pixelRayDirection, model, skyBoxImageSphereTexture, 0);
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//			return new Vector3f(0);			
////////////////////////////////////////////////////////////////////////////////////
		}
	}

	/** Performs ray tracing for a given ray.
	 * @param incidentRayOrigin The origin of the incident ray.
	 * @param incidentRayDirection The direction of the incident ray.
	 * @param model The model containing spheres and materials.
	 * @param skyBoxImageSphereTexture The texture for the skybox.
	 * @param depthLevel The current depth level of the recursion (for limiting recursion).
	 * @return The calculated color for the pixel based on ray tracing and lighting effects. */	
	private static Vector3f rayTracing(Vector3f incidentRayOrigin, Vector3f incidentRayDirection, Model model,
			SphereTexture skyBoxImageSphereTexture, int depthLevel) {

		Vector3f returnedColor = new Vector3f();
		
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
		if (depthLevel == depthOfRayTracing)
			return returnedColor.set(0);

		if (exercise.ordinal() <= ExerciseEnum.EX_2___Rays_calculation.ordinal())
			return skyBoxImageSphereTexture.sampleDirectionFromMiddle(incidentRayDirection);

		// intersection test
		/////////////////////////////////////////
		IntersectionResults intersectionResults;
		switch (exercise) {
		case EX_3_1_Intersection_One_sphere:
		case EX_3_2_Intersection_One_sphere_with_color:
			intersectionResults = rayIntersection(incidentRayOrigin, incidentRayDirection, model.spheres.get(0));
			break;
		case EX_3_3_Intersection_List_of_spheres:
		case EX_3_4_Intersection_Finding_the_nearest_sphere:
		default:
			// this is the exercise delta
			intersectionResults = rayIntersection(incidentRayOrigin, incidentRayDirection, model.spheres); 
			// this is the exercise delta
		}
		
		//returning sky-box if no intersection
		/////////////////////////////////////////
		if (intersectionResults==null)
			return skyBoxImageSphereTexture.sampleDirectionFromMiddle(incidentRayDirection);

		ModelSphere intersectedSphere = intersectionResults.intersectedSphere;
		ModelMaterial intersectedSphereMaterial = model.materials.get(intersectedSphere.materialIndex);
		Vector3f intersectionPoint = intersectionResults.intersectionPoint;
		Vector3f intersectionNormal = intersectionResults.normal;
		boolean intersectionFromOutsideOfSphere = intersectionResults.rayFromOutsideOfSphere;
		SphereTexture intersectedSphereTexture = model.skyBoxImageSphereTextures
				.get(intersectedSphere.textureIndex);
		
		// sphere color
		/////////////////////////////////////////
		switch (exercise) {
		case EX_3_1_Intersection_One_sphere:
			returnedColor.add(new Vector3f(0));
			return returnedColor; //in this exercise still no other code till the end
		case EX_3_2_Intersection_One_sphere_with_color:
		case EX_3_3_Intersection_List_of_spheres:
		case EX_3_4_Intersection_Finding_the_nearest_sphere:
			// this is the exercise delta
			Vector3f color1 = new Vector3f(intersectedSphereMaterial.color);
			float kColor1 = intersectedSphereMaterial.kColor;
			color1.mul(kColor1);
			returnedColor.add(color1);
			// this is the exercise delta
			return returnedColor; //in this exercise still no other code till the end
		default:
			Vector3f color = new Vector3f(intersectedSphereMaterial.color);
			float kColor = intersectedSphereMaterial.kColor;
			color.mul(kColor);
			returnedColor.add(color);
		}

		if (exercise.ordinal() >= ExerciseEnum.EX_4_1_Lighting_Diffusive.ordinal()) {
			ModelLight light = model.lights.get(0);

			//shadow test
			/////////////////////////////////////////
			boolean pointInShadow = false;
			if (exercise.ordinal() >= ExerciseEnum.EX_6___Shadow.ordinal()) {
				pointInShadow = isPointInShadow(light.location, intersectionPoint, intersectionNormal, model);
			}

			// texture
			/////////////////////////////////////////
			Vector3f kd;
			if (exercise.ordinal() >= ExerciseEnum.EX_5___Texture.ordinal()) {
				float kTexture = intersectedSphereMaterial.kTexture;
				kd = calcKdCombinedWithTexture(intersectionPoint, intersectedSphere.center, intersectedSphereTexture, intersectedSphereMaterial.kd, kTexture);
			} else {
				kd = intersectedSphereMaterial.kd;
			}

			// direct light
			/////////////////////////////////////////
			Vector3f directLightIntensity = new Vector3f(0);
			if (!pointInShadow) {
				directLightIntensity = lightingEquation(intersectionPoint, intersectionNormal, light.location, kd,
						intersectedSphereMaterial.ks, intersectedSphereMaterial.ka,
						intersectedSphereMaterial.shininess);
				directLightIntensity.mul(light.intensity);
			} else
				directLightIntensity = new Vector3f(intersectedSphereMaterial.ka).mul(light.intensity);

			float kDirect = intersectedSphereMaterial.kDirect;
			directLightIntensity.mul(kDirect);
			returnedColor.add(directLightIntensity);
		}

		// reflected light
		/////////////////////////////////////////
		if (exercise.ordinal() >= ExerciseEnum.EX_7___Reflection.ordinal()) {
			Vector3f reflectedLight = calcReflectedLight(incidentRayDirection, intersectionPoint, intersectionNormal, model, skyBoxImageSphereTexture, depthLevel);
			float kReflection = intersectedSphereMaterial.kReflection;
			returnedColor.add(reflectedLight.mul(kReflection));
		}

		// transmission light
		/////////////////////////////////////////
		if (exercise.ordinal() >= ExerciseEnum.EX_8___Transparency.ordinal()) {
			float refractiveIndexIntersectedSphere = intersectedSphereMaterial.refractiveIndex;
			Vector3f transmittedLight = calcTransmissionLight(incidentRayDirection, intersectionPoint, intersectionNormal, intersectionFromOutsideOfSphere, refractiveIndexIntersectedSphere, model,
					skyBoxImageSphereTexture, depthLevel);
			float kTransmission = intersectedSphereMaterial.kTransmission;
			returnedColor.add(transmittedLight.mul(kTransmission));
		}
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

		return returnedColor;
	}

	
	/** Calculates the direction of a ray for a given pixel in the image.
	 * @param x The x-coordinate of the pixel.
	 * @param y The y-coordinate of the pixel.
	 * @param imageWidth The width of the image.
	 * @param imageHeight The height of the image.
	 * @param fovXdegree The horizontal field of view in degrees.
	 * @return The normalized direction vector of the ray for the given pixel. */	
	static Vector3f calcPixelDirection(int x, int y, int imageWidth, int imageHeight, float fovXdegree) {
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
		// Calculate the field of view (FOV) in radians
		float fovX = (float) (fovXdegree / 180 * Math.PI);
		float fovY = (float) fovX * imageHeight / imageWidth;

		// Calculate the direction of the ray for the pixel (x, y)
		float tanX = (float) Math.tan(fovX / 2.0);
		float dir_x = -tanX + 2 * x * tanX / (imageWidth - 1);
		float tanY = (float) Math.tan(fovY / 2.0);
		float dir_y = -tanY + 2 * y * tanY / (imageHeight - 1);

		// returning the direction of the ray from the camera through the pixel
		return new Vector3f(dir_x, dir_y, -1.0f).normalize();
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//      return new Vector3f(0);
////////////////////////////////////////////////////////////////////////////////////
	}

	/** Calculates the intersection(s) between a ray and a sphere.
	 * @param rayStart The starting point of the ray in world space.
	 * @param rayDirection The normalized direction vector of the ray.
	 * @param sphere The sphere to check for intersection.
	 * @return An IntersectionResults object containing information about the intersection,
	 *         or an empty IntersectionResults object if no intersection occurs. */	
	static IntersectionResults rayIntersection(Vector3f rayStart, Vector3f rayDirection, ModelSphere sphere) {
		Vector3f sphereCenter = sphere.center;
		float sphereRadius = sphere.radius;

		// Project the lineToSphere vector onto the line direction to find the distance
		// from
		// the line point to the closest point on the line to the sphere center
		float tm = new Vector3f(sphereCenter).sub(rayStart).dot(rayDirection);

		// If the closest point on the line is behind the line point, then there are no
		// intersection points
		if (tm < 0)
			return null;

		// Calculate the distance from the closest point on the line to the sphere
		// center
		Vector3f pm = new Vector3f(rayStart).add(new Vector3f(rayDirection).mul(tm));
		float pmDistance = pm.distance(sphereCenter);

		// If the distance from the closest point to the sphere center is greater than
		// the sphere radius,
		// then there are no intersection points
		if (pmDistance > sphereRadius)
			return null;

		// Calculate the distance along the line from the closest point to the
		// intersection points
		float dt = (float) Math.sqrt(sphereRadius * sphereRadius - pmDistance * pmDistance);

		// Calculate the intersection points
		if (dt > tm) {
			Vector3f firstIntersectionPoint = pm.add(new Vector3f(rayDirection).mul(dt));
			return new IntersectionResults(true, // intersected
					firstIntersectionPoint, // firstIntersectionPoint
					new Vector3f(sphereCenter).sub(firstIntersectionPoint).normalize(), // normal
					false, // rayFromOutsideOfSphere
					sphere); // intersectedSphere
		} else {
			Vector3f firstIntersectionPoint = pm.sub(new Vector3f(rayDirection).mul(dt));
			return new IntersectionResults(true, // intersected
					firstIntersectionPoint, // firstIntersectionPoint
					new Vector3f(firstIntersectionPoint).sub(sphereCenter).normalize(), // normal
					true, // rayFromOutsideOfSphere
					sphere); // intersectedSphere
		}
	}


	/** Finds the nearest intersection between a ray and a list of spheres.
	 * @param rayStart The starting point of the ray.
	 * @param rayDirection The normalized direction of the ray.
	 * @param spheres The list of spheres to check for intersections.
	 * @return An IntersectionResults object containing information about the nearest intersection,
	 *         or an empty IntersectionResults object if no intersection occurs. */	
	private static IntersectionResults rayIntersection(Vector3f rayStart, Vector3f rayDirection,
			List<ModelSphere> spheres) {
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
		float nearerIntersectionDistance = Float.MAX_VALUE;

		// Iterate over all spheres to check intersection
		IntersectionResults methodIntersectionResults = null;
		for(ModelSphere sphere: spheres) {
			IntersectionResults currentIntersectionResults = rayIntersection(rayStart, rayDirection, sphere);
			if (currentIntersectionResults!=null) {
				float currentIntersectionDistance = -currentIntersectionResults.intersectionPoint.z; 
				// Assuming negative Z is nearer

				boolean ex_3_4_or_more = exercise.ordinal() >= ExerciseEnum.EX_3_4_Intersection_Finding_the_nearest_sphere.ordinal();
				if (currentIntersectionDistance < nearerIntersectionDistance || !ex_3_4_or_more) {
					nearerIntersectionDistance = currentIntersectionDistance;
					methodIntersectionResults = currentIntersectionResults;
				}
			}
		}

		return methodIntersectionResults;
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//		return null;
////////////////////////////////////////////////////////////////////////////////////
	}

	
	/** Calculates the lighting at a specific point.
	 * @param point The Eye space position of the point.
	 * @param pointNormal The normal vector at the point.
	 * @param lightPos The Eye space position of the light source.
	 * @param Kd The diffuse color coefficient of the material.
	 * @param Ks The specular color coefficient of the material.
	 * @param Ka The ambient color coefficient of the material.
	 * @param shininess The shininess parameter for specular highlights.
	 * @return The calculated lighting as a Vector3f representing color. */	
	static Vector3f lightingEquation(Vector3f point, Vector3f PointNormal, Vector3f LightPos, Vector3f Kd,
			Vector3f Ks, Vector3f Ka, float shininess) {

		Vector3f returnedColor = new Vector3f();

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
		// LightDirection
		Vector3f LightDirection = new Vector3f(LightPos).sub(point).normalize();

		// Diffuse component: Kd * ( max(0, N · L ))
		if (exercise.ordinal() >= ExerciseEnum.EX_4_1_Lighting_Diffusive.ordinal()) {
			float NdotL = PointNormal.dot(LightDirection);
			Vector3f diffuse = new Vector3f(Kd).mul(Math.max(0.0f, NdotL));
			returnedColor.add(diffuse);
		}

		// Ambient component: Ka
		if (exercise.ordinal() >= ExerciseEnum.EX_4_2_Lighting_Ambient.ordinal()) {
			Vector3f ambient = new Vector3f(Ka);
			returnedColor.add(ambient);
		}

		// Specular component: Ks * ( max(0, R · V) )^n
		if (exercise.ordinal() >= ExerciseEnum.EX_4_3_Lighting_Specular.ordinal()) {
			// EyeDirection
			Vector3f EyePos = new Vector3f(0, 0, 0);
			Vector3f EyeDirection = new Vector3f(EyePos).sub(point).normalize();

			// Calculate ReflectionDirection based on LightDirection and PointNormal
			float NdotL = PointNormal.dot(LightDirection);
			Vector3f ReflectionDirection;
			if (NdotL > 0) {
				ReflectionDirection = new Vector3f(PointNormal).mul(2.0f * NdotL).sub(LightDirection).normalize();
			} else {
				ReflectionDirection = new Vector3f(0, 0, 0);
			}

			// Specular component: Ks * (R · V)^n (guarding against negative R · V)
			float RdotV = Math.max(0.0f, ReflectionDirection.dot(EyeDirection));
			Vector3f specular = new Vector3f(Ks).mul((float) Math.pow(RdotV, shininess));
			returnedColor.add(specular);
		}

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

		return returnedColor;
	}


	/**
	 * Calculates the combined diffuse reflection coefficient (Kd) for a point on the surface of a sphere,
	 * taking into account both the base material's Kd and the texture applied to the sphere.
	 * 
	 * @param intersectionPoint the point of intersection on the sphere's surface in 3D space.
	 * @param intersectedSphereCenter the center of the intersected sphere.
	 * @param intersectedSphereTexture the texture applied to the sphere, used to sample color based on direction.
	 * @param intersectedSphereKd the base diffuse reflection coefficient of the sphere's material.
	 * @param kTexture the blending factor between the base Kd and the texture color 
	 *                 (0 for only base Kd, 1 for only texture, values in between for blending).
	 * @return a {@link Vector3f} representing the combined Kd, computed as a weighted blend of the base Kd and the texture color.
	 */
	static Vector3f calcKdCombinedWithTexture(
			Vector3f intersectionPoint,
			Vector3f intersectedSphereCenter,
			SphereTexture intersectedSphereTexture,
			Vector3f intersectedSphereKd,
			float kTexture) {
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
		// calculate the direction of intersection point from the center of sphere
		Vector3f directionFromCenter = new Vector3f(intersectionPoint).sub(intersectedSphereCenter).normalize();
		// updating kd with the texture color
		Vector3f sphereTextureColor = intersectedSphereTexture.sampleDirectionFromMiddle(directionFromCenter);
		Vector3f kd = new Vector3f(sphereTextureColor).mul(kTexture).add(new Vector3f(intersectedSphereKd).mul(1-kTexture));
		return kd;
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//return null;
////////////////////////////////////////////////////////////////////////////////////
	}	


	/**
	 * Determines whether a given point is in shadow with respect to a specified light source.
	 * 
	 * <p>The method calculates a shadow ray originating just above the surface of the given point
	 * (offset slightly along the surface normal to prevent self-intersection) and checks whether
	 * this ray intersects with any objects in the scene model.</p>
	 * 
	 * @param lightLocation the position of the light source in 3D space.
	 * @param point the position of the point being tested for shadow in 3D space.
	 * @param pointNormal the surface normal vector at the point, used to offset the shadow ray origin.
	 * @param model the {@link Model} representing the scene, containing the objects (e.g., spheres) to check for intersection.
	 * @return {@code true} if the point is in shadow (i.e., the shadow ray intersects with any objects), {@code false} otherwise.
	 */
	static boolean isPointInShadow(
			Vector3f lightLocation,
			Vector3f point,
			Vector3f pointNormal,
			Model model) {
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
		Vector3f shadowRayDir = new Vector3f(lightLocation).sub(point).normalize();
		Vector3f shadowRayOrigin = new Vector3f(point).add(new Vector3f(pointNormal).mul(0.01f));
		IntersectionResults lightIntersectionResults = 
				rayIntersection(shadowRayOrigin, shadowRayDir, model.spheres);
		return lightIntersectionResults!=null;
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//return false;
////////////////////////////////////////////////////////////////////////////////////
	}	

	
	/**
	 * Calculates the reflected light at an intersection point, accounting for reflections
	 * within the scene and the skybox texture.
	 * 
	 * <p>The method computes the direction of the reflected ray based on the incident ray 
	 * and the surface normal at the intersection point. It then recursively traces the 
	 * reflected ray through the scene to compute the reflected light contribution.</p>
	 * 
	 * @param incidentRayDirection the direction of the incoming ray hitting the surface.
	 * @param intersectionPoint the point on the surface where the reflection occurs.
	 * @param intersectionNormal the normal vector at the intersection point.
	 * @param kReflection the reflection coefficient, controlling the intensity of the reflected light.
	 * @param model the {@link Model} representing the scene, containing objects for ray tracing.
	 * @param skyBoxImageSphereTexture the texture of the skybox used to simulate distant reflections.
	 * @param depthLevel the current recursion depth, used to limit the number of reflection bounces.
	 * @return a {@link Vector3f} representing the color/intensity of the reflected light at the intersection point.
	 */
	static Vector3f calcReflectedLight(Vector3f incidentRayDirection, 
	                                   Vector3f intersectionPoint, 
	                                   Vector3f intersectionNormal, 
	                                   Model model, 
	                                   SphereTexture skyBoxImageSphereTexture, 
	                                   int depthLevel) {
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
		Vector3f reflectedRayDir = new Vector3f(incidentRayDirection)
				.sub(new Vector3f(intersectionNormal).mul(2.0f * incidentRayDirection.dot(intersectionNormal)));
		Vector3f reflectedLight = 
				rayTracing(intersectionPoint, reflectedRayDir, model, skyBoxImageSphereTexture, depthLevel + 1);
		return reflectedLight;
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//return null;
////////////////////////////////////////////////////////////////////////////////////
	}

	
	
	
	/**
	 * Calculates the transmitted (refracted) light at an intersection point, considering the refraction 
	 * properties of the intersected object and the scene environment.
	 * 
	 * <p>The method computes the direction of the transmitted ray based on the incident ray, 
	 * the surface normal, and the refractive index of the intersected sphere. It offsets the ray 
	 * origin slightly to prevent self-intersection and recursively traces the transmitted ray 
	 * through the scene to determine the contribution of transmitted light.</p>
	 * 
	 * @param incidentRayDirection the direction of the incoming ray hitting the surface.
	 * @param intersectionPoint the point on the surface where the refraction occurs.
	 * @param intersectionNormal the normal vector at the intersection point.
	 * @param intersectionFromOutsideOfSphere {@code true} if the intersection occurs when the ray 
	 *                                         enters the sphere from outside, {@code false} if exiting.
	 * @param refractiveIndexIntersectedSphere the refractive index of the intersected sphere material.
	 * @param kTransmission the transmission coefficient, controlling the intensity of the transmitted light.
	 * @param model the {@link Model} representing the scene, containing objects for ray tracing.
	 * @param skyBoxImageSphereTexture the texture of the skybox used to simulate distant light transmission.
	 * @param depthLevel the current recursion depth, used to limit the number of refraction bounces.
	 * @return a {@link Vector3f} representing the color/intensity of the transmitted light at the intersection point.
	 */
	static Vector3f calcTransmissionLight(Vector3f incidentRayDirection, 
	                                      Vector3f intersectionPoint, 
	                                      Vector3f intersectionNormal, 
	                                      boolean intersectionFromOutsideOfSphere, 
	                                      float refractiveIndexIntersectedSphere, 
	                                      Model model, 
	                                      SphereTexture skyBoxImageSphereTexture, 
	                                      int depthLevel) {
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
		Vector3f transmittedRayDir = YoursUtilities.calcTransmissionRay(incidentRayDirection, intersectionNormal,
				refractiveIndexIntersectedSphere, intersectionFromOutsideOfSphere);
		Vector3f transmittedRayOrig;
		if(intersectionFromOutsideOfSphere)
			transmittedRayOrig = new Vector3f(intersectionNormal).mul(-0.01f).add(intersectionPoint);
		else
			transmittedRayOrig = new Vector3f(intersectionNormal).mul(0.01f).add(intersectionPoint);

		Vector3f transmittedLight = 
				rayTracing(transmittedRayOrig, transmittedRayDir, model, skyBoxImageSphereTexture, depthLevel + 1);
		return transmittedLight;
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
/////////////// solution ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//return null;
////////////////////////////////////////////////////////////////////////////////////
	}
}


