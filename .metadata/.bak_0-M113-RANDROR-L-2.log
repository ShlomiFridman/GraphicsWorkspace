!SESSION 2024-09-25 08:56:29.816 -----------------------------------------------
eclipse.buildId=4.28.0.20230608-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file D:\My_Documents\OneDrive - ORT Braude College of Engineering\DOK\Graphics\workspace\.metadata\.bak_4.log
Created Time: 2024-09-25 11:35:18.711

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:35:18.711
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:35:18.712
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:18.834
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul()
			mul(vertex.normal,)
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:35:18.835
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:35:18.835
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:21.146
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul()
			mul(vertex.normal,)
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:35:21.147
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:35:21.147
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:24.604
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul()
			mul(vertex.normal,)
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:35:24.605
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:35:24.605
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:28.558
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewMmul(vertex.normal,)
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:35:28.558
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:35:28.559
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:28.696
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewMmul(vertex.normal,)
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:35:28.696
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:35:28.697
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:29.804
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,)
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:35:29.805
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:35:29.805
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:29.900
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,)
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:35:29.901
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:35:29.902
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:31.977
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,)
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:35:31.978
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:35:31.978
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:34.730
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,)
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:35:34.731
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:35:34.732
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:39.012
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,)
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:35:39.013
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:35:39.014
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:39.449
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,)
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:309)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:243)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:655)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.internal.BidiUtil.windowProc(BidiUtil.java:663)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:35:39.450
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:309)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:243)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:655)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.internal.BidiUtil.windowProc(BidiUtil.java:663)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:35:39.450
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:309)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:243)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:655)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.internal.BidiUtil.windowProc(BidiUtil.java:663)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:40.944
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,)
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:35:40.945
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:35:40.946
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:41.620
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,vertex.NormalEyeCoordinates)
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:35:41.621
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:35:41.622
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:42.132
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,vertex.NormalEyeCoordinates)
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:35:42.135
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:35:42.136
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:43.216
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,vertex.NormalEyeCoordinates);
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:35:43.217
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:35:43.218
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:35:43.324
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,vertex.NormalEyeCoordinates);
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:35:43.325
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:35:43.337
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:36:14.343
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,vertex.NormalEyeCoordinates);
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:36:14.344
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:36:14.345
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:36:25.296
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,vertex.NormalEyeCoordinates);
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:36:25.298
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:36:25.299
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:36:26.947
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,vertex.NormalEyeCoordinates);
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:36:26.948
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:36:26.949
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:36:33.211
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,vertex.NormalEyeCoordinates);
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:36:33.212
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:36:33.213
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:36:40.204
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			vertex.NormalEyeCoordinates = new Vector3f();
			modelviewM.mul(vertex.normal,vertex.NormalEyeCoordinates);
			
			glm::vec3 temp13;
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:36:40.205
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:36:40.206
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 20:52:54.865
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.IOException;
import java.util.List;

import org.joml.Matrix3f;
import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(intBufferWrapper, vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f t = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(t);
		vertex.point3DeyeCoordinates = new Vector3f(t.x, t.y, t.z);

		// Apply projection transformation
		projectionM.transform(t);

		// Perspective divide if w is non-zero
		if (t.w != 0) {
			t.mul(1 / t.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(t);
		vertex.pointScreen = new Vector3f(t.x, t.y, t.z);

		// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
		Matrix3f modelviewM3x3 = new Matrix3f();
		modelviewM.get3x3(modelviewM3x3);
		vertex.NormalEyeCoordinates = new Vector3f();
		modelviewM3x3.transform(vertex.normal,vertex.NormalEyeCoordinates);
		
		if (worldModel.displayNormals) {
			//drawing normals 
			Vector3f t1 = new Vector3f(vertex.NormalEyeCoordinates);
			Vector4f point3D_plusNormal_eyeCoordinates = new Vector4f(
							           t1.mul(0.1f)
							             .add(vertex.point3DeyeCoordinates),1);
			Vector4f t2 = new Vector4f(point3D_plusNormal_eyeCoordinates);
			//modelviewM.transform(t2);
			projectionM.transform(t2);
			if (t2.w != 0) {
				t2.mul(1 / t2.w);
			} else { 
				System.err.println("Division by w == 0 in vertexProcessing normal transformation");
			}
			viewportM.transform(t2);
			Vector3f point3D_plusNormal_screen = new Vector3f(t2.x,t2.y,t2.z); 
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
		
//		vertex.pixelValue = LightingEquation(vertex.point3DeyeCoordinates, vertex.NormalEyeCoordinates, 
//        glm::vec3(TheGuiApi.params.LightPosition[0], TheGuiApi.params.LightPosition[1], TheGuiApi.params.LightPosition[2]), TheGuiApi.params.Lighting_Diffuse, TheGuiApi.params.Lighting_Specular, TheGuiApi.params.Lighting_Ambient, TheGuiApi.params.Lighting_sHininess);

		vertex.pixelValue = LightingEquation(vertex.point3DeyeCoordinates, vertex.NormalEyeCoordinates, 
				                             worldModel.lightPosition, worldModel.lighting_Diffuse, 
				                             worldModel.lighting_Specular, worldModel.lighting_Ambient, worldModel.lighting_sHininess);

		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, 
											                       vertex1.color, vertex2.color, vertex3.color, 
											                       pixelColor);
								}
							
							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								if (worldModel.displayType == DisplayTypeEnum.LIGHTING_FLAT) {
									float mainPixelValue = (vertex1.pixelValue + vertex2.pixelValue + vertex3.pixelValue)/3; 
									pixelColor[0] = mainPixelValue; pixelColor[1] = mainPixelValue; pixelColor[2] = mainPixelValue;  
								} else if (worldModel.displayType == DisplayTypeEnum.LIGHTING_GOURARD) {
									barycentricInterpolation_color(barycentricCoordinates, 
						                       vertex1.pixelValue, vertex2.pixelValue, vertex3.pixelValue, 
						                       pixelColor);
								} else if (worldModel.displayType == DisplayTypeEnum.LIGHTING_GOURARD) {
							
								}
							}
						

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1round = Math.round(p1.x);
			int y1round = Math.round(p1.y);
			int x2round = Math.round(p2.x);
			int y2round = Math.round(p2.y);
			
			int x1, y1, x2, y2;
			if (   (y2round - y1round)  < -(x2round - x1round) || 
				 ( (y2round - y1round) == -(x2round - x1round) ) &&  ( (x2round-x1round)<0 ) )  {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			} else {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dy) <= Math.abs(dx) ) {
	            float a = (dx == 0) ? 0 : dy / dx;  // Avoid division by zero
				float y = y1;
				int yi;
				for (int x = x1; x < x2; x++) {
					yi = Math.round(y);
					if(x>=0 && x<imageWidth && yi>=0 && yi<imageHeight)
						intBufferWrapper.setPixel(x, yi, r, g, b);
					y = y + a;
				}
			} else {
	            float a = (dy == 0) ? 0 : dx / dy;  // Avoid division by zero
				float x = x1;
				int xi;
				for (int y = y1; y < y2; y++) {
					xi = Math.round(x);
					if(xi>=0 && xi<imageWidth && y>=0 && y<imageHeight)
						intBufferWrapper.setPixel(xi, y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}


	float LightingEquation(Vector3f point, Vector3f PointNormal, Vector3f LightPos, float Kd, float Ks, float Ka, float n)
	{
		PointNormal.normalize();
		
		//LightDirection
		Vector3f LightDirection = new Vector3f(LightPos).sub(point).normalize();

		//EyeDirection
		Vector3f EyePos = new Vector3f(0,0,0);
		Vector3f EyeDirection = new Vector3f(EyePos).sub(point).normalize();

		//ReflectionDirection
		Vector3f ReflectionDirection;
		if ( LightDirection.dot(PointNormal) > 0) {
			ReflectionDirection = new Vector3f(LightDirection)
					.sub(   new Vector3f(PointNormal).mul(- 2.0f * LightDirection.dot(PointNormal))		);
		}
		else {
			ReflectionDirection = new Vector3f(0, 0, 0);
		}
		return Math.round(Ka) (Math.max(0.0f, Kd * PointNormal.dot(LightDirection)) + 
			            Math.max(0.0f, Ks * Math.pow( EyeDirection.dot(ReflectionDirection), n) ) + 
			            Math.max(0.0f, Ka));
	}



}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 20:52:54.890
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 20:52:54.890
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 20:52:56.518
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.IOException;
import java.util.List;

import org.joml.Matrix3f;
import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(intBufferWrapper, vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f t = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(t);
		vertex.point3DeyeCoordinates = new Vector3f(t.x, t.y, t.z);

		// Apply projection transformation
		projectionM.transform(t);

		// Perspective divide if w is non-zero
		if (t.w != 0) {
			t.mul(1 / t.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(t);
		vertex.pointScreen = new Vector3f(t.x, t.y, t.z);

		// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
		Matrix3f modelviewM3x3 = new Matrix3f();
		modelviewM.get3x3(modelviewM3x3);
		vertex.NormalEyeCoordinates = new Vector3f();
		modelviewM3x3.transform(vertex.normal,vertex.NormalEyeCoordinates);
		
		if (worldModel.displayNormals) {
			//drawing normals 
			Vector3f t1 = new Vector3f(vertex.NormalEyeCoordinates);
			Vector4f point3D_plusNormal_eyeCoordinates = new Vector4f(
							           t1.mul(0.1f)
							             .add(vertex.point3DeyeCoordinates),1);
			Vector4f t2 = new Vector4f(point3D_plusNormal_eyeCoordinates);
			//modelviewM.transform(t2);
			projectionM.transform(t2);
			if (t2.w != 0) {
				t2.mul(1 / t2.w);
			} else { 
				System.err.println("Division by w == 0 in vertexProcessing normal transformation");
			}
			viewportM.transform(t2);
			Vector3f point3D_plusNormal_screen = new Vector3f(t2.x,t2.y,t2.z); 
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
		
//		vertex.pixelValue = LightingEquation(vertex.point3DeyeCoordinates, vertex.NormalEyeCoordinates, 
//        glm::vec3(TheGuiApi.params.LightPosition[0], TheGuiApi.params.LightPosition[1], TheGuiApi.params.LightPosition[2]), TheGuiApi.params.Lighting_Diffuse, TheGuiApi.params.Lighting_Specular, TheGuiApi.params.Lighting_Ambient, TheGuiApi.params.Lighting_sHininess);

		vertex.pixelValue = LightingEquation(vertex.point3DeyeCoordinates, vertex.NormalEyeCoordinates, 
				                             worldModel.lightPosition, worldModel.lighting_Diffuse, 
				                             worldModel.lighting_Specular, worldModel.lighting_Ambient, worldModel.lighting_sHininess);

		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, 
											                       vertex1.color, vertex2.color, vertex3.color, 
											                       pixelColor);
								}
							
							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								if (worldModel.displayType == DisplayTypeEnum.LIGHTING_FLAT) {
									float mainPixelValue = (vertex1.pixelValue + vertex2.pixelValue + vertex3.pixelValue)/3; 
									pixelColor[0] = mainPixelValue; pixelColor[1] = mainPixelValue; pixelColor[2] = mainPixelValue;  
								} else if (worldModel.displayType == DisplayTypeEnum.LIGHTING_GOURARD) {
									barycentricInterpolation_color(barycentricCoordinates, 
						                       vertex1.pixelValue, vertex2.pixelValue, vertex3.pixelValue, 
						                       pixelColor);
								} else if (worldModel.displayType == DisplayTypeEnum.LIGHTING_GOURARD) {
							
								}
							}
						

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1round = Math.round(p1.x);
			int y1round = Math.round(p1.y);
			int x2round = Math.round(p2.x);
			int y2round = Math.round(p2.y);
			
			int x1, y1, x2, y2;
			if (   (y2round - y1round)  < -(x2round - x1round) || 
				 ( (y2round - y1round) == -(x2round - x1round) ) &&  ( (x2round-x1round)<0 ) )  {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			} else {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dy) <= Math.abs(dx) ) {
	            float a = (dx == 0) ? 0 : dy / dx;  // Avoid division by zero
				float y = y1;
				int yi;
				for (int x = x1; x < x2; x++) {
					yi = Math.round(y);
					if(x>=0 && x<imageWidth && yi>=0 && yi<imageHeight)
						intBufferWrapper.setPixel(x, yi, r, g, b);
					y = y + a;
				}
			} else {
	            float a = (dy == 0) ? 0 : dx / dy;  // Avoid division by zero
				float x = x1;
				int xi;
				for (int y = y1; y < y2; y++) {
					xi = Math.round(x);
					if(xi>=0 && xi<imageWidth && y>=0 && y<imageHeight)
						intBufferWrapper.setPixel(xi, y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}


	float LightingEquation(Vector3f point, Vector3f PointNormal, Vector3f LightPos, float Kd, float Ks, float Ka, float n)
	{
		PointNormal.normalize();
		
		//LightDirection
		Vector3f LightDirection = new Vector3f(LightPos).sub(point).normalize();

		//EyeDirection
		Vector3f EyePos = new Vector3f(0,0,0);
		Vector3f EyeDirection = new Vector3f(EyePos).sub(point).normalize();

		//ReflectionDirection
		Vector3f ReflectionDirection;
		if ( LightDirection.dot(PointNormal) > 0) {
			ReflectionDirection = new Vector3f(LightDirection)
					.sub(   new Vector3f(PointNormal).mul(- 2.0f * LightDirection.dot(PointNormal))		);
		}
		else {
			ReflectionDirection = new Vector3f(0, 0, 0);
		}
		return Math.round() (Math.max(0.0f, Kd * PointNormal.dot(LightDirection)) + 
			            Math.max(0.0f, Ks * Math.pow( EyeDirection.dot(ReflectionDirection), n) ) + 
			            Math.max(0.0f, Ka));
	}



}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 20:52:56.520
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 20:52:56.521
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 20:55:27.993
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.IOException;
import java.util.List;

import org.joml.Matrix3f;
import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(intBufferWrapper, vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f t = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(t);
		vertex.point3DeyeCoordinates = new Vector3f(t.x, t.y, t.z);

		// Apply projection transformation
		projectionM.transform(t);

		// Perspective divide if w is non-zero
		if (t.w != 0) {
			t.mul(1 / t.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(t);
		vertex.pointScreen = new Vector3f(t.x, t.y, t.z);

		// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
		Matrix3f modelviewM3x3 = new Matrix3f();
		modelviewM.get3x3(modelviewM3x3);
		vertex.NormalEyeCoordinates = new Vector3f();
		modelviewM3x3.transform(vertex.normal,vertex.NormalEyeCoordinates);
		
		if (worldModel.displayNormals) {
			//drawing normals 
			Vector3f t1 = new Vector3f(vertex.NormalEyeCoordinates);
			Vector4f point3D_plusNormal_eyeCoordinates = new Vector4f(
							           t1.mul(0.1f)
							             .add(vertex.point3DeyeCoordinates),1);
			Vector4f t2 = new Vector4f(point3D_plusNormal_eyeCoordinates);
			//modelviewM.transform(t2);
			projectionM.transform(t2);
			if (t2.w != 0) {
				t2.mul(1 / t2.w);
			} else { 
				System.err.println("Division by w == 0 in vertexProcessing normal transformation");
			}
			viewportM.transform(t2);
			Vector3f point3D_plusNormal_screen = new Vector3f(t2.x,t2.y,t2.z); 
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
		
//		vertex.pixelValue = LightingEquation(vertex.point3DeyeCoordinates, vertex.NormalEyeCoordinates, 
//        glm::vec3(TheGuiApi.params.LightPosition[0], TheGuiApi.params.LightPosition[1], TheGuiApi.params.LightPosition[2]), TheGuiApi.params.Lighting_Diffuse, TheGuiApi.params.Lighting_Specular, TheGuiApi.params.Lighting_Ambient, TheGuiApi.params.Lighting_sHininess);

		vertex.pixelValue = LightingEquation(vertex.point3DeyeCoordinates, vertex.NormalEyeCoordinates, 
				                             worldModel.lightPosition, worldModel.lighting_Diffuse, 
				                             worldModel.lighting_Specular, worldModel.lighting_Ambient, worldModel.lighting_sHininess);

		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, 
											                       vertex1.color, vertex2.color, vertex3.color, 
											                       pixelColor);
								}
							
							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								if (worldModel.displayType == DisplayTypeEnum.LIGHTING_FLAT) {
									float mainPixelValue = (vertex1.pixelValue + vertex2.pixelValue + vertex3.pixelValue)/3; 
									pixelColor[0] = mainPixelValue; pixelColor[1] = mainPixelValue; pixelColor[2] = mainPixelValue;  
								} else if (worldModel.displayType == DisplayTypeEnum.LIGHTING_GOURARD) {
									barycentricInterpolation_color(barycentricCoordinates, 
						                       vertex1.pixelValue, vertex2.pixelValue, vertex3.pixelValue, 
						                       pixelColor);
								} else if (worldModel.displayType == DisplayTypeEnum.LIGHTING_GOURARD) {
							
								}
							}
						

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1round = Math.round(p1.x);
			int y1round = Math.round(p1.y);
			int x2round = Math.round(p2.x);
			int y2round = Math.round(p2.y);
			
			int x1, y1, x2, y2;
			if (   (y2round - y1round)  < -(x2round - x1round) || 
				 ( (y2round - y1round) == -(x2round - x1round) ) &&  ( (x2round-x1round)<0 ) )  {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			} else {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dy) <= Math.abs(dx) ) {
	            float a = (dx == 0) ? 0 : dy / dx;  // Avoid division by zero
				float y = y1;
				int yi;
				for (int x = x1; x < x2; x++) {
					yi = Math.round(y);
					if(x>=0 && x<imageWidth && yi>=0 && yi<imageHeight)
						intBufferWrapper.setPixel(x, yi, r, g, b);
					y = y + a;
				}
			} else {
	            float a = (dy == 0) ? 0 : dx / dy;  // Avoid division by zero
				float x = x1;
				int xi;
				for (int y = y1; y < y2; y++) {
					xi = Math.round(x);
					if(xi>=0 && xi<imageWidth && y>=0 && y<imageHeight)
						intBufferWrapper.setPixel(xi, y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}


	float LightingEquation(Vector3f point, Vector3f PointNormal, Vector3f LightPos, float Kd, float Ks, float Ka, float n)
	{
		PointNormal.normalize();
		
		//LightDirection
		Vector3f LightDirection = new Vector3f(LightPos).sub(point).normalize();

		//EyeDirection
		Vector3f EyePos = new Vector3f(0,0,0);
		Vector3f EyeDirection = new Vector3f(EyePos).sub(point).normalize();

		//ReflectionDirection
		Vector3f ReflectionDirection;
		if ( LightDirection.dot(PointNormal) > 0) {
			ReflectionDirection = new Vector3f(LightDirection)
					.sub(   new Vector3f(PointNormal).mul(- 2.0f * LightDirection.dot(PointNormal))		);
		}
		else {
			ReflectionDirection = new Vector3f(0, 0, 0);
		}
		return Math.round(Ka) (Math.max(0.0f, Kd * PointNormal.dot(LightDirection)) + 
			            Math.max(0.0f, Ks * Math.pow( EyeDirection.dot(ReflectionDirection), n) ) + 
			            Math.max(0.0f, Ka));
	}



}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 20:55:27.995
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 20:55:27.995
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 20:55:28.020
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.IOException;
import java.util.List;

import org.joml.Matrix3f;
import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(intBufferWrapper, vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f t = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(t);
		vertex.point3DeyeCoordinates = new Vector3f(t.x, t.y, t.z);

		// Apply projection transformation
		projectionM.transform(t);

		// Perspective divide if w is non-zero
		if (t.w != 0) {
			t.mul(1 / t.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(t);
		vertex.pointScreen = new Vector3f(t.x, t.y, t.z);

		// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
		Matrix3f modelviewM3x3 = new Matrix3f();
		modelviewM.get3x3(modelviewM3x3);
		vertex.NormalEyeCoordinates = new Vector3f();
		modelviewM3x3.transform(vertex.normal,vertex.NormalEyeCoordinates);
		
		if (worldModel.displayNormals) {
			//drawing normals 
			Vector3f t1 = new Vector3f(vertex.NormalEyeCoordinates);
			Vector4f point3D_plusNormal_eyeCoordinates = new Vector4f(
							           t1.mul(0.1f)
							             .add(vertex.point3DeyeCoordinates),1);
			Vector4f t2 = new Vector4f(point3D_plusNormal_eyeCoordinates);
			//modelviewM.transform(t2);
			projectionM.transform(t2);
			if (t2.w != 0) {
				t2.mul(1 / t2.w);
			} else { 
				System.err.println("Division by w == 0 in vertexProcessing normal transformation");
			}
			viewportM.transform(t2);
			Vector3f point3D_plusNormal_screen = new Vector3f(t2.x,t2.y,t2.z); 
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
		
//		vertex.pixelValue = LightingEquation(vertex.point3DeyeCoordinates, vertex.NormalEyeCoordinates, 
//        glm::vec3(TheGuiApi.params.LightPosition[0], TheGuiApi.params.LightPosition[1], TheGuiApi.params.LightPosition[2]), TheGuiApi.params.Lighting_Diffuse, TheGuiApi.params.Lighting_Specular, TheGuiApi.params.Lighting_Ambient, TheGuiApi.params.Lighting_sHininess);

		vertex.pixelValue = LightingEquation(vertex.point3DeyeCoordinates, vertex.NormalEyeCoordinates, 
				                             worldModel.lightPosition, worldModel.lighting_Diffuse, 
				                             worldModel.lighting_Specular, worldModel.lighting_Ambient, worldModel.lighting_sHininess);

		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, 
											                       vertex1.color, vertex2.color, vertex3.color, 
											                       pixelColor);
								}
							
							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								if (worldModel.displayType == DisplayTypeEnum.LIGHTING_FLAT) {
									float mainPixelValue = (vertex1.pixelValue + vertex2.pixelValue + vertex3.pixelValue)/3; 
									pixelColor[0] = mainPixelValue; pixelColor[1] = mainPixelValue; pixelColor[2] = mainPixelValue;  
								} else if (worldModel.displayType == DisplayTypeEnum.LIGHTING_GOURARD) {
									barycentricInterpolation_color(barycentricCoordinates, 
						                       vertex1.pixelValue, vertex2.pixelValue, vertex3.pixelValue, 
						                       pixelColor);
								} else if (worldModel.displayType == DisplayTypeEnum.LIGHTING_GOURARD) {
							
								}
							}
						

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1round = Math.round(p1.x);
			int y1round = Math.round(p1.y);
			int x2round = Math.round(p2.x);
			int y2round = Math.round(p2.y);
			
			int x1, y1, x2, y2;
			if (   (y2round - y1round)  < -(x2round - x1round) || 
				 ( (y2round - y1round) == -(x2round - x1round) ) &&  ( (x2round-x1round)<0 ) )  {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			} else {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dy) <= Math.abs(dx) ) {
	            float a = (dx == 0) ? 0 : dy / dx;  // Avoid division by zero
				float y = y1;
				int yi;
				for (int x = x1; x < x2; x++) {
					yi = Math.round(y);
					if(x>=0 && x<imageWidth && yi>=0 && yi<imageHeight)
						intBufferWrapper.setPixel(x, yi, r, g, b);
					y = y + a;
				}
			} else {
	            float a = (dy == 0) ? 0 : dx / dy;  // Avoid division by zero
				float x = x1;
				int xi;
				for (int y = y1; y < y2; y++) {
					xi = Math.round(x);
					if(xi>=0 && xi<imageWidth && y>=0 && y<imageHeight)
						intBufferWrapper.setPixel(xi, y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}


	float LightingEquation(Vector3f point, Vector3f PointNormal, Vector3f LightPos, float Kd, float Ks, float Ka, float n)
	{
		PointNormal.normalize();
		
		//LightDirection
		Vector3f LightDirection = new Vector3f(LightPos).sub(point).normalize();

		//EyeDirection
		Vector3f EyePos = new Vector3f(0,0,0);
		Vector3f EyeDirection = new Vector3f(EyePos).sub(point).normalize();

		//ReflectionDirection
		Vector3f ReflectionDirection;
		if ( LightDirection.dot(PointNormal) > 0) {
			ReflectionDirection = new Vector3f(LightDirection)
					.sub(   new Vector3f(PointNormal).mul(- 2.0f * LightDirection.dot(PointNormal))		);
		}
		else {
			ReflectionDirection = new Vector3f(0, 0, 0);
		}
		return Math.round(Ka) (Math.max(0.0f, Kd * PointNormal.dot(LightDirection)) + 
			            Math.max(0.0f, Ks * Math.pow( EyeDirection.dot(ReflectionDirection), n) ) + 
			            Math.max(0.0f, Ka));
	}



}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 20:55:28.022
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 20:55:28.024
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-09-26 06:20:57.495 -----------------------------------------------
eclipse.buildId=4.30.0.20231201-1200
java.version=17.0.9
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.emf.ecore 2 0 2024-09-26 06:22:23.522
!MESSAGE Both 'org.eclipse.jst.j2ee.core' and 'org.eclipse.jst.j2ee.core' register a package for 'application.xmi'

!ENTRY ch.qos.logback.classic 1 0 2024-09-26 06:22:24.194
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY org.eclipse.core.resources 4 567 2024-09-26 06:22:38.167
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2024-09-26 06:22:38.167
!MESSAGE Could not read metadata for '.org.eclipse.egit.core.cmp'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/.org.eclipse.egit.core.cmp)[567]: java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:955)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:954)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:934)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:790)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1616)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2620)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2324)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:571)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:947)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:258)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:185)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:324)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:267)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:545)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:525)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:208)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:651)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:588)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1459)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2024-09-26 06:22:38.173
!MESSAGE The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:955)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:954)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:934)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:790)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1616)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2620)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2324)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:571)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:947)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:258)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:185)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:324)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:267)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:545)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:525)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:208)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:651)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:588)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1459)

!ENTRY ch.qos.logback.classic 1 0 2024-09-26 06:22:38.926
!MESSAGE Logback config file: C:\RanDocs\OneDrive - ORT Braude College of Engineering\DOK\Graphics\workspace\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.2.1.20231030-1438.xml

!ENTRY org.eclipse.jface 2 0 2024-09-26 06:22:43.250
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-09-26 06:22:43.250
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-09-26 06:22:57.012
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\rand'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.ide 4 4 2024-09-26 08:01:47.110
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:668)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:300)
	at org.eclipse.jface.resource.DeferredImageDescriptor.createImage(DeferredImageDescriptor.java:85)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:56)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:92)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:89)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:71)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:92)
	at org.eclipse.ui.actions.OpenWithMenu.getImage(OpenWithMenu.java:137)
	at org.eclipse.ui.actions.OpenWithMenu.createMenuItem(OpenWithMenu.java:174)
	at org.eclipse.ui.actions.OpenWithMenu.fill(OpenWithMenu.java:271)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4802)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:208)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:206)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:294)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:304)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.reconcileManagerToModel(MenuManagerRenderer.java:1076)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.reconcileManagerToModel(MenuManagerRenderer.java:1014)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:379)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4273)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5141)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4773)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2305)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5039)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4112)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3653)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:342)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:648)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:342)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:555)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:173)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:208)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:651)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:588)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1459)

!ENTRY org.eclipse.ui.ide 4 4 2024-09-26 08:01:47.191
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:668)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:300)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:56)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:92)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:96)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:71)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:92)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.getImage(AbstractContributionItem.java:151)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.updateIcons(AbstractContributionItem.java:177)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.update(AbstractContributionItem.java:127)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.fill(AbstractContributionItem.java:264)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4802)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:208)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:206)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:191)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:202)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:256)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:114)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4273)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5141)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4773)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2305)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5039)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4112)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3653)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:342)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:648)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:342)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:555)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:173)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:208)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:651)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:588)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1459)

!ENTRY org.eclipse.ui.ide 4 4 2024-09-26 08:01:47.193
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:668)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:300)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:56)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:92)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:96)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:71)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:92)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.getImage(AbstractContributionItem.java:151)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.updateIcons(AbstractContributionItem.java:177)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.update(AbstractContributionItem.java:127)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.fill(AbstractContributionItem.java:264)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4802)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:208)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:206)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:191)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:202)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:256)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:114)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4273)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5141)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4773)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2305)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5039)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4112)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3653)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:342)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:648)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:342)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:555)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:173)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:208)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:651)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:588)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1459)

!ENTRY org.eclipse.ui.ide 4 4 2024-09-26 08:01:47.194
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:668)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:300)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:56)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:92)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:96)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:71)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:92)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.getImage(AbstractContributionItem.java:151)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.updateIcons(AbstractContributionItem.java:177)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.update(AbstractContributionItem.java:127)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.fill(AbstractContributionItem.java:264)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4802)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:208)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:206)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:191)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:202)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:256)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:114)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4273)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5141)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4773)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2305)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5039)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4112)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3653)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:342)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:648)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:342)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:555)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:173)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:208)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:651)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:588)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1459)
!SESSION 2024-09-26 08:20:58.349 -----------------------------------------------
eclipse.buildId=4.28.0.20230608-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2024-09-26 08:22:43.680
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2024-09-26 08:22:43.680
!MESSAGE Could not read metadata for '.org.eclipse.egit.core.cmp'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/.org.eclipse.egit.core.cmp)[567]: java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:894)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:874)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:730)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2549)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2254)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:571)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:545)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:525)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2024-09-26 08:22:43.681
!MESSAGE The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:894)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:874)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:730)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2549)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2254)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:571)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:545)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:525)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2024-09-26 08:22:47.326
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-09-26 08:22:47.326
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.266
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.datatools.connectivity.DataSourceExplorerNavigator" id and the "Data Source Explorer" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.267
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.datatools.sqltools.plan.planView" id and the "Execution Plan" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.267
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.datatools.sqltools.result.resultView" id and the "SQL Results" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.268
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.jpt.ui.jpaStructureView" id and the "JPA Structure" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.268
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.jpt.ui.jpaDetailsView" id and the "JPA Details" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.269
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.jst.jsf.ui.component.ComponentTreeView" id and the "JSF Component Tree" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.269
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.jst.jsf.ui.tagregistry.TagRegistryView" id and the "Tag Registry" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.270
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.jst.ws.jaxws.ui.views.AnnotationsView" id and the "Annotation Properties" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.271
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.lsp4e.operations.typeHierarchy.TypeHierarchyView" id and the "Type Hierarchy" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.272
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.lsp4e.ui.languageServersView" id and the "Language Servers" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.272
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.mylyn.commons.identity.ui.navigator.People" id and the "People" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.273
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.pde.api.tools.ui.views.apitooling.views.apitoolingview" id and the "API Tools" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.273
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.pde.runtime.RegistryBrowser" id and the "Plug-in Registry" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.274
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.wst.internet.monitor.view" id and the "TCP/IP Monitor" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.274
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.wst.jsdt.callhierarchy.view" id and the "Call Hierarchy" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.275
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.wst.jsdt.ui.SourceView" id and the "Declaration" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.284
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.wst.jsdt.ui.JavadocView" id and the "Documentation" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.285
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.wst.server.ui.ServersView" id and the "Servers" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.285
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.wst.xml.views.XPathView" id and the "XPath" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.286
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.wst.xsl.jaxp.debug.ui.resultview" id and the "Result" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2024-09-26 08:22:53.286
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.wst.xsl.ui.view.outline" id and the "Stylesheet Model" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.egit.ui 2 0 2024-09-26 08:22:53.510
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\win1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 2 0 2024-09-26 13:55:13.845
!MESSAGE The 'org.eclipse.jdt.ui.JavaAllCompletionProposalComputer' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension took too long to return from the 'computeCompletionProposals()' operation.

!ENTRY org.eclipse.jdt.debug.ui 4 150 2024-09-26 14:00:15.006
!MESSAGE Internal Error
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1378)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1013)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getThis(JDIStackFrame.java:1432)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.lambda$3(JavaDebugHover.java:651)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findFirstFrameForVariable(JavaDebugHover.java:604)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:388)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
Caused by: java.lang.IllegalStateException
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1381)
	... 9 more
!SUBENTRY 1 org.eclipse.jdt.debug 4 100 2024-09-26 14:00:15.057
!MESSAGE Invalid stack frame
!STACK 0
java.lang.IllegalStateException
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1381)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1013)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getThis(JDIStackFrame.java:1432)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.lambda$3(JavaDebugHover.java:651)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findFirstFrameForVariable(JavaDebugHover.java:604)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:388)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 4 125 2024-09-26 14:00:15.066
!MESSAGE Internal error logged from JDI Debug: 
!STACK 0
java.lang.IllegalStateException
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1381)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1013)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getThis(JDIStackFrame.java:1432)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.evaluateField(JavaDebugHover.java:528)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:388)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug.ui 4 150 2024-09-26 14:00:23.895
!MESSAGE Internal Error
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1378)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1013)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getThis(JDIStackFrame.java:1432)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.lambda$3(JavaDebugHover.java:651)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findFirstFrameForVariable(JavaDebugHover.java:604)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover$1Evaluator.run(JavaDebugHover.java:574)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.evaluateQualifiedNode(JavaDebugHover.java:590)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:386)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
Caused by: java.lang.IllegalStateException
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1381)
	... 11 more
!SUBENTRY 1 org.eclipse.jdt.debug 4 100 2024-09-26 14:00:23.895
!MESSAGE Invalid stack frame
!STACK 0
java.lang.IllegalStateException
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1381)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1013)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getThis(JDIStackFrame.java:1432)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.lambda$3(JavaDebugHover.java:651)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findFirstFrameForVariable(JavaDebugHover.java:604)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover$1Evaluator.run(JavaDebugHover.java:574)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.evaluateQualifiedNode(JavaDebugHover.java:590)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:386)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ltk.ui.refactoring 4 10000 2024-09-26 15:41:03.535
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Core Exception [code 4] Problems encountered while moving resources.
	at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:180)
	at org.eclipse.jdt.internal.core.CopyResourceElementsOperation.processElements(CopyResourceElementsOperation.java:461)
	at org.eclipse.jdt.internal.core.MultiOperation.executeOperation(MultiOperation.java:95)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:811)
	at org.eclipse.jdt.internal.core.JavaModel.rename(JavaModel.java:296)
	at org.eclipse.jdt.internal.core.PackageFragment.rename(PackageFragment.java:533)
	at org.eclipse.jdt.internal.corext.refactoring.changes.RenamePackageChange.renamePackage(RenamePackageChange.java:210)
	at org.eclipse.jdt.internal.corext.refactoring.changes.RenamePackageChange.doRename(RenamePackageChange.java:121)
	at org.eclipse.jdt.internal.corext.refactoring.AbstractJavaElementRenameChange.perform(AbstractJavaElementRenameChange.java:92)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.access$0(DynamicValidationStateChange.java:1)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.lambda$0(DynamicValidationStateChange.java:105)
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:41)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5961)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.perform(DynamicValidationStateChange.java:106)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.lambda$0(PerformChangeOperation.java:258)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:295)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:94)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:219)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:89)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
Caused by: org.eclipse.core.internal.resources.ResourceException: Problems encountered while moving resources.
	at org.eclipse.core.internal.resources.Resource.move(Resource.java:1525)
	at org.eclipse.core.internal.resources.Resource.move(Resource.java:1480)
	at org.eclipse.jdt.internal.core.CopyResourceElementsOperation.processPackageFragmentResource(CopyResourceElementsOperation.java:512)
	at org.eclipse.jdt.internal.core.CopyResourceElementsOperation.processElement(CopyResourceElementsOperation.java:446)
	at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:168)
	... 31 more
Caused by: org.eclipse.core.internal.resources.ResourceException: Problems encountered while moving resources.
	at org.eclipse.core.internal.resources.Resource.move(Resource.java:1525)
	at org.eclipse.core.internal.resources.Resource.move(Resource.java:1480)
	at org.eclipse.jdt.internal.core.CopyResourceElementsOperation.processPackageFragmentResource(CopyResourceElementsOperation.java:512)
	at org.eclipse.jdt.internal.core.CopyResourceElementsOperation.processElement(CopyResourceElementsOperation.java:446)
	at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:168)
	at org.eclipse.jdt.internal.core.CopyResourceElementsOperation.processElements(CopyResourceElementsOperation.java:461)
	at org.eclipse.jdt.internal.core.MultiOperation.executeOperation(MultiOperation.java:95)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:811)
	at org.eclipse.jdt.internal.core.JavaModel.rename(JavaModel.java:296)
	at org.eclipse.jdt.internal.core.PackageFragment.rename(PackageFragment.java:533)
	at org.eclipse.jdt.internal.corext.refactoring.changes.RenamePackageChange.renamePackage(RenamePackageChange.java:210)
	at org.eclipse.jdt.internal.corext.refactoring.changes.RenamePackageChange.doRename(RenamePackageChange.java:121)
	at org.eclipse.jdt.internal.corext.refactoring.AbstractJavaElementRenameChange.perform(AbstractJavaElementRenameChange.java:92)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.access$0(DynamicValidationStateChange.java:1)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.lambda$0(DynamicValidationStateChange.java:105)
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:41)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5961)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.perform(DynamicValidationStateChange.java:106)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.lambda$0(PerformChangeOperation.java:258)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:295)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:94)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:219)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:89)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
Contains: Resource is out of sync with the file system: '/Rasterization/src/rasterization_app'.
!SUBENTRY 1 org.eclipse.jdt.core 4 966 2024-09-26 15:41:03.553
!MESSAGE Problems encountered while moving resources.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while moving resources.
	at org.eclipse.core.internal.resources.Resource.move(Resource.java:1525)
	at org.eclipse.core.internal.resources.Resource.move(Resource.java:1480)
	at org.eclipse.jdt.internal.core.CopyResourceElementsOperation.processPackageFragmentResource(CopyResourceElementsOperation.java:512)
	at org.eclipse.jdt.internal.core.CopyResourceElementsOperation.processElement(CopyResourceElementsOperation.java:446)
	at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:168)
	at org.eclipse.jdt.internal.core.CopyResourceElementsOperation.processElements(CopyResourceElementsOperation.java:461)
	at org.eclipse.jdt.internal.core.MultiOperation.executeOperation(MultiOperation.java:95)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:811)
	at org.eclipse.jdt.internal.core.JavaModel.rename(JavaModel.java:296)
	at org.eclipse.jdt.internal.core.PackageFragment.rename(PackageFragment.java:533)
	at org.eclipse.jdt.internal.corext.refactoring.changes.RenamePackageChange.renamePackage(RenamePackageChange.java:210)
	at org.eclipse.jdt.internal.corext.refactoring.changes.RenamePackageChange.doRename(RenamePackageChange.java:121)
	at org.eclipse.jdt.internal.corext.refactoring.AbstractJavaElementRenameChange.perform(AbstractJavaElementRenameChange.java:92)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.access$0(DynamicValidationStateChange.java:1)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.lambda$0(DynamicValidationStateChange.java:105)
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:41)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5961)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.perform(DynamicValidationStateChange.java:106)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.lambda$0(PerformChangeOperation.java:258)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:295)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:94)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:219)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:89)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
Contains: Resource is out of sync with the file system: '/Rasterization/src/rasterization_app'.
!SUBENTRY 2 org.eclipse.core.resources 1 4 2024-09-26 15:41:03.553
!MESSAGE Problems encountered while moving resources.
!SUBENTRY 3 org.eclipse.core.resources 1 4 2024-09-26 15:41:03.553
!MESSAGE Resource is out of sync with the file system: '/Rasterization/src/rasterization_app'.

!ENTRY org.eclipse.jdt.core 4 966 2024-09-26 15:41:03.749
!MESSAGE Problems encountered while moving resources.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while moving resources.
	at org.eclipse.core.internal.resources.Resource.move(Resource.java:1525)
	at org.eclipse.core.internal.resources.Resource.move(Resource.java:1480)
	at org.eclipse.jdt.internal.core.CopyResourceElementsOperation.processPackageFragmentResource(CopyResourceElementsOperation.java:512)
	at org.eclipse.jdt.internal.core.CopyResourceElementsOperation.processElement(CopyResourceElementsOperation.java:446)
	at org.eclipse.jdt.internal.core.MultiOperation.processElements(MultiOperation.java:168)
	at org.eclipse.jdt.internal.core.CopyResourceElementsOperation.processElements(CopyResourceElementsOperation.java:461)
	at org.eclipse.jdt.internal.core.MultiOperation.executeOperation(MultiOperation.java:95)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:811)
	at org.eclipse.jdt.internal.core.JavaModel.rename(JavaModel.java:296)
	at org.eclipse.jdt.internal.core.PackageFragment.rename(PackageFragment.java:533)
	at org.eclipse.jdt.internal.corext.refactoring.changes.RenamePackageChange.renamePackage(RenamePackageChange.java:210)
	at org.eclipse.jdt.internal.corext.refactoring.changes.RenamePackageChange.doRename(RenamePackageChange.java:121)
	at org.eclipse.jdt.internal.corext.refactoring.AbstractJavaElementRenameChange.perform(AbstractJavaElementRenameChange.java:92)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.access$0(DynamicValidationStateChange.java:1)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.lambda$0(DynamicValidationStateChange.java:105)
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:41)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5961)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.perform(DynamicValidationStateChange.java:106)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.lambda$0(PerformChangeOperation.java:258)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:295)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:94)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:219)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:89)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
Contains: Resource is out of sync with the file system: '/Rasterization/src/rasterization_app'.
!SUBENTRY 1 org.eclipse.core.resources 1 4 2024-09-26 15:41:03.749
!MESSAGE Problems encountered while moving resources.
!SUBENTRY 2 org.eclipse.core.resources 1 4 2024-09-26 15:41:03.749
!MESSAGE Resource is out of sync with the file system: '/Rasterization/src/rasterization_app'.

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2024-09-26 15:48:37.570
!MESSAGE Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor ObjectModel.java
!STACK 0
java.lang.IllegalStateException: Disconnected before saving. Please post stacktrace to https://bugs.eclipse.org/bugs/show_bug.cgi?id=569286 org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor ObjectModel.java
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.disconnectEditor(AbstractTextEditor.java:7148)
	at org.eclipse.ui.texteditor.AbstractTextEditor.dispose(AbstractTextEditor.java:4329)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.dispose(AbstractDecoratedTextEditor.java:383)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.dispose(JavaEditor.java:2668)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.dispose(CompilationUnitEditor.java:1517)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.invalidate(CompatibilityPart.java:264)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.destroy(CompatibilityPart.java:421)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:987)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:952)
	at org.eclipse.e4.core.internal.di.InjectorImpl.uninject(InjectorImpl.java:193)
	at org.eclipse.e4.core.internal.di.Requestor.uninject(Requestor.java:177)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:89)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:103)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.removeListenersTo(EclipseContext.java:487)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.uninject(ContextInjectionFactory.java:184)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:947)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.subscribeTopicToBeRendered(PartRenderingEngine.java:185)
	at jdk.internal.reflect.GeneratedMethodAccessor84.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.di.internal.extensions.EventObjectSupplier$DIEventHandler.handleEvent(EventObjectSupplier.java:92)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setToBeRendered(UIElementImpl.java:314)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1404)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1334)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1317)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1177)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1970)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:337)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	Suppressed: java.lang.IllegalStateException: isDirty check after disconnect
		at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7197)
		at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3431)
		at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3404)
		at org.eclipse.ui.ide.IDE$1.run(IDE.java:1458)
		at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
		at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1446)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
		at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
		at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
		at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
		at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:172)
		at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
		at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
		at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4047)
		at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3663)
		... 21 more

!ENTRY org.eclipse.jdt.core 4 4 2024-09-26 16:15:32.448
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.IOException;
import java.util.List;

import org.joml.Matrix3f;
import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import app_interface.DisplayTypeEnum;
import app_interface.ExerciseEnum;
import app_interface.IntBufferWrapper;
import app_interface.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;
	private IntBufferWrapper textureImageIntBufferWrapper;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			textureImageIntBufferWrapper = objLoader.getTextureImageIntBufferWrapper();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(intBufferWrapper, vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f t = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(t);
		vertex.point3DeyeCoordinates = new Vector3f(t.x, t.y, t.z);

		// Apply projection transformation
		projectionM.transform(t);

		// Perspective divide if w is non-zero
		if (t.w != 0) {
			t.mul(1 / t.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(t);
		vertex.pointScreen = new Vector3f(t.x, t.y, t.z);

		// transformation normal from object coordinates to eye coordinates v->normal
		// --> v->NormalEyeCoordinates
		Matrix3f modelviewM3x3 = new Matrix3f();
		modelviewM.get3x3(modelviewM3x3);
		vertex.NormalEyeCoordinates = new Vector3f();
		modelviewM3x3.transform(vertex.normal, vertex.NormalEyeCoordinates);

		if (worldModel.displayNormals) {
			// drawing normals
			Vector3f t1 = new Vector3f(vertex.NormalEyeCoordinates);
			Vector4f point3D_plusNormal_eyeCoordinates = new Vector4f(t1.mul(0.1f).add(vertex.point3DeyeCoordinates),
					1);
			Vector4f t2 = new Vector4f(point3D_plusNormal_eyeCoordinates);
			// modelviewM.transform(t2);
			projectionM.transform(t2);
			if (t2.w != 0) {
				t2.mul(1 / t2.w);
			} else {
				System.err.println("Division by w == 0 in vertexProcessing normal transformation");
			}
			viewportM.transform(t2);
			Vector3f point3D_plusNormal_screen = new Vector3f(t2.x, t2.y, t2.z);
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}

//		vertex.pixelValue = LightingEquation(vertex.point3DeyeCoordinates, vertex.NormalEyeCoordinates, 
//        glm::vec3(TheGuiApi.params.LightPosition[0], TheGuiApi.params.LightPosition[1], TheGuiApi.params.LightPosition[2]), TheGuiApi.params.Lighting_Diffuse, TheGuiApi.params.Lighting_Specular, TheGuiApi.params.Lighting_Ambient, TheGuiApi.params.Lighting_sHininess);

		vertex.lightingIntensity0to1 = LightingEquation(vertex.point3DeyeCoordinates, vertex.NormalEyeCoordinates,
				worldModel.lightPosition, worldModel.lighting_Diffuse, worldModel.lighting_Specular,
				worldModel.lighting_Ambient, worldModel.lighting_sHininess);

	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor, Vertex3f faceNormal) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_9.ordinal()) {
								if (worldModel.displayType == DisplayTypeEnum.LIGHTING_FLAT) {
									faceNormal -
									
									short meanlightingIntensity0to255 = (short) Math
											.round((vertex1.lightingIntensity0to1 + vertex2.lightingIntensity0to1
													+ vertex3.lightingIntensity0to1) / 3f * 255f);
									pixelColor[0] = meanlightingIntensity0to255;
									pixelColor[1] = meanlightingIntensity0to255;
									pixelColor[2] = meanlightingIntensity0to255;
								} else if (worldModel.displayType == DisplayTypeEnum.LIGHTING_GOURARD) {
									short pixellightingIntensity0to255 = (short) (255f * barycentricInterpolation(
											barycentricCoordinates, vertex1.lightingIntensity0to1,
											vertex2.lightingIntensity0to1, vertex3.lightingIntensity0to1));
									pixelColor[0] = pixellightingIntensity0to255;
									pixelColor[1] = pixellightingIntensity0to255;
									pixelColor[2] = pixellightingIntensity0to255;
								} else if (worldModel.displayType == DisplayTypeEnum.LIGHTING_PHONG) {
									Vector3f pixelPoint3DeyeCoordinates = barycentricInterpolation(
											barycentricCoordinates, vertex1.point3DeyeCoordinates,
											vertex2.point3DeyeCoordinates, vertex3.point3DeyeCoordinates);
									Vector3f pixelNormalEyeCoordinates = barycentricInterpolation(
											barycentricCoordinates, vertex1.NormalEyeCoordinates,
											vertex2.NormalEyeCoordinates, vertex3.NormalEyeCoordinates);
									short pixellightingIntensity0to255 = (short) (255f
											* LightingEquation(pixelPoint3DeyeCoordinates, pixelNormalEyeCoordinates,
													worldModel.lightPosition, worldModel.lighting_Diffuse,
													worldModel.lighting_Specular, worldModel.lighting_Ambient,
													worldModel.lighting_sHininess));
									pixelColor[0] = pixellightingIntensity0to255;
									pixelColor[1] = pixellightingIntensity0to255;
									pixelColor[2] = pixellightingIntensity0to255;
								}
							}
							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_10.ordinal()) {
								if (worldModel.displayType == DisplayTypeEnum.TEXTURE) {
									Vector2f pixelTextureCoordinates = barycentricInterpolation(
											barycentricCoordinates, vertex1.textureCoordinates,
											vertex2.textureCoordinates, vertex3.textureCoordinates);
									textureImageIntBufferWrapper.getPixel(
											(int)Math.floor(pixelTextureCoordinates.x * (textureImageIntBufferWrapper.getImageWidth()-1)), 
											(int)Math.floor(pixelTextureCoordinates.y * (textureImageIntBufferWrapper.getImageHeight()-1)), pixelColor);
								}
								if (worldModel.displayType == DisplayTypeEnum.TEXTURE_LIGHTING) {
									Vector3f pixelPoint3DeyeCoordinates = barycentricInterpolation(
											barycentricCoordinates, vertex1.point3DeyeCoordinates,
											vertex2.point3DeyeCoordinates, vertex3.point3DeyeCoordinates);
									Vector3f pixelNormalEyeCoordinates = barycentricInterpolation(
											barycentricCoordinates, vertex1.NormalEyeCoordinates,
											vertex2.NormalEyeCoordinates, vertex3.NormalEyeCoordinates);
									float pixellightingIntensity0to1 = LightingEquation(pixelPoint3DeyeCoordinates, pixelNormalEyeCoordinates,
													worldModel.lightPosition, worldModel.lighting_Diffuse,
													worldModel.lighting_Specular, worldModel.lighting_Ambient,
													worldModel.lighting_sHininess);
									Vector2f pixelTextureCoordinates = barycentricInterpolation(
											barycentricCoordinates, vertex1.textureCoordinates,
											vertex2.textureCoordinates, vertex3.textureCoordinates);
									textureImageIntBufferWrapper.getPixel(
											(int)Math.floor(pixelTextureCoordinates.x * (textureImageIntBufferWrapper.getImageWidth()-1)), 
											(int)Math.floor(pixelTextureCoordinates.y * (textureImageIntBufferWrapper.getImageHeight()-1)), pixelColor);
									pixelColor[0] = (short)(pixellightingIntensity0to1 * 1.3f * (float)pixelColor[0]);
									pixelColor[1] = (short)(pixellightingIntensity0to1 * 1.3f * (float)pixelColor[1]);
									pixelColor[2] = (short)(pixellightingIntensity0to1 * 1.3f * (float)pixelColor[2]);
								}

							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1round = Math.round(p1.x);
			int y1round = Math.round(p1.y);
			int x2round = Math.round(p2.x);
			int y2round = Math.round(p2.y);

			int x1, y1, x2, y2;
			if ((y2round - y1round) < -(x2round - x1round)
					|| ((y2round - y1round) == -(x2round - x1round)) && ((x2round - x1round) < 0)) {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			} else {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dy) <= Math.abs(dx)) {
				float a = (dx == 0) ? 0 : dy / dx; // Avoid division by zero
				float y = y1;
				int yi;
				for (int x = x1; x < x2; x++) {
					yi = Math.round(y);
					if (x >= 0 && x < imageWidth && yi >= 0 && yi < imageHeight)
						intBufferWrapper.setPixel(x, yi, r, g, b);
					y = y + a;
				}
			} else {
				float a = (dy == 0) ? 0 : dx / dy; // Avoid division by zero
				float x = x1;
				int xi;
				for (int y = y1; y < y2; y++) {
					xi = Math.round(x);
					if (xi >= 0 && xi < imageWidth && y >= 0 && y < imageHeight)
						intBufferWrapper.setPixel(xi, y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		float x = p1_property.x * barycentricCoordinates.get(0) + p2_property.x * barycentricCoordinates.get(1)
				+ p3_property.x * barycentricCoordinates.get(2);
		float y = p1_property.y * barycentricCoordinates.get(0) + p2_property.y * barycentricCoordinates.get(1)
				+ p3_property.y * barycentricCoordinates.get(2);
		return new Vector2f(x, y);
	}

	private Vector3f barycentricInterpolation(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		float x = p1_property.x * barycentricCoordinates.x + p2_property.x * barycentricCoordinates.y
				+ p3_property.x * barycentricCoordinates.z;
		float y = p1_property.y * barycentricCoordinates.x + p2_property.y * barycentricCoordinates.y
				+ p3_property.y * barycentricCoordinates.z;
		float z = p1_property.z * barycentricCoordinates.x + p2_property.z * barycentricCoordinates.y
				+ p3_property.z * barycentricCoordinates.z;
		return new Vector3f(x, y, z);
	}

	private void barycentricInterpolation(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

	float LightingEquation(Vector3f point, Vector3f PointNormal, Vector3f LightPos, float Kd, float Ks, float Ka,
			float n) {
		// Normalize point normal
		PointNormal.normalize();

		// LightDirection
		Vector3f LightDirection = new Vector3f(LightPos).sub(point).normalize();

		// EyeDirection
		Vector3f EyePos = new Vector3f(0, 0, 0);
		Vector3f EyeDirection = new Vector3f(EyePos).sub(point).normalize();

		// Calculate ReflectionDirection based on LightDirection and PointNormal
		Vector3f ReflectionDirection;
		float NdotL = PointNormal.dot(LightDirection);
		if (NdotL > 0) {
			ReflectionDirection = new Vector3f(PointNormal).mul(2.0f * NdotL).sub(LightDirection).normalize();
		} else {
			ReflectionDirection = new Vector3f(0, 0, 0);
		}


		// Diffuse component: Kd * (N · L)
		float diffuse = Math.max(0.0f, Kd * NdotL);

		// Specular component: Ks * (R · V)^n (guarding against negative R · V)
		float RdotV = Math.max(0.0f, ReflectionDirection.dot(EyeDirection));
		float specular = Ks * (float) Math.pow(RdotV, n);
		
		// Ambient component: Ka
		float ambient = Math.max(0.0f, Ka);

		// Return the sum of the components
		return diffuse + specular + ambient;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2238)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3100)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2238)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3100)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-26 16:15:32.453
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2238)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3100)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2238)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3100)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-26 16:15:32.454
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2238)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3100)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2238)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3100)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-26 16:15:32.582
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.IOException;
import java.util.List;

import org.joml.Matrix3f;
import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import app_interface.DisplayTypeEnum;
import app_interface.ExerciseEnum;
import app_interface.IntBufferWrapper;
import app_interface.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;
	private IntBufferWrapper textureImageIntBufferWrapper;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			textureImageIntBufferWrapper = objLoader.getTextureImageIntBufferWrapper();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(intBufferWrapper, vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f t = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(t);
		vertex.point3DeyeCoordinates = new Vector3f(t.x, t.y, t.z);

		// Apply projection transformation
		projectionM.transform(t);

		// Perspective divide if w is non-zero
		if (t.w != 0) {
			t.mul(1 / t.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(t);
		vertex.pointScreen = new Vector3f(t.x, t.y, t.z);

		// transformation normal from object coordinates to eye coordinates v->normal
		// --> v->NormalEyeCoordinates
		Matrix3f modelviewM3x3 = new Matrix3f();
		modelviewM.get3x3(modelviewM3x3);
		vertex.NormalEyeCoordinates = new Vector3f();
		modelviewM3x3.transform(vertex.normal, vertex.NormalEyeCoordinates);

		if (worldModel.displayNormals) {
			// drawing normals
			Vector3f t1 = new Vector3f(vertex.NormalEyeCoordinates);
			Vector4f point3D_plusNormal_eyeCoordinates = new Vector4f(t1.mul(0.1f).add(vertex.point3DeyeCoordinates),
					1);
			Vector4f t2 = new Vector4f(point3D_plusNormal_eyeCoordinates);
			// modelviewM.transform(t2);
			projectionM.transform(t2);
			if (t2.w != 0) {
				t2.mul(1 / t2.w);
			} else {
				System.err.println("Division by w == 0 in vertexProcessing normal transformation");
			}
			viewportM.transform(t2);
			Vector3f point3D_plusNormal_screen = new Vector3f(t2.x, t2.y, t2.z);
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}

//		vertex.pixelValue = LightingEquation(vertex.point3DeyeCoordinates, vertex.NormalEyeCoordinates, 
//        glm::vec3(TheGuiApi.params.LightPosition[0], TheGuiApi.params.LightPosition[1], TheGuiApi.params.LightPosition[2]), TheGuiApi.params.Lighting_Diffuse, TheGuiApi.params.Lighting_Specular, TheGuiApi.params.Lighting_Ambient, TheGuiApi.params.Lighting_sHininess);

		vertex.lightingIntensity0to1 = LightingEquation(vertex.point3DeyeCoordinates, vertex.NormalEyeCoordinates,
				worldModel.lightPosition, worldModel.lighting_Diffuse, worldModel.lighting_Specular,
				worldModel.lighting_Ambient, worldModel.lighting_sHininess);

	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor, Vertex3f faceNormal) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_9.ordinal()) {
								if (worldModel.displayType == DisplayTypeEnum.LIGHTING_FLAT) {
									faceNormal -
									
									short meanlightingIntensity0to255 = (short) Math
											.round((vertex1.lightingIntensity0to1 + vertex2.lightingIntensity0to1
													+ vertex3.lightingIntensity0to1) / 3f * 255f);
									pixelColor[0] = meanlightingIntensity0to255;
									pixelColor[1] = meanlightingIntensity0to255;
									pixelColor[2] = meanlightingIntensity0to255;
								} else if (worldModel.displayType == DisplayTypeEnum.LIGHTING_GOURARD) {
									short pixellightingIntensity0to255 = (short) (255f * barycentricInterpolation(
											barycentricCoordinates, vertex1.lightingIntensity0to1,
											vertex2.lightingIntensity0to1, vertex3.lightingIntensity0to1));
									pixelColor[0] = pixellightingIntensity0to255;
									pixelColor[1] = pixellightingIntensity0to255;
									pixelColor[2] = pixellightingIntensity0to255;
								} else if (worldModel.displayType == DisplayTypeEnum.LIGHTING_PHONG) {
									Vector3f pixelPoint3DeyeCoordinates = barycentricInterpolation(
											barycentricCoordinates, vertex1.point3DeyeCoordinates,
											vertex2.point3DeyeCoordinates, vertex3.point3DeyeCoordinates);
									Vector3f pixelNormalEyeCoordinates = barycentricInterpolation(
											barycentricCoordinates, vertex1.NormalEyeCoordinates,
											vertex2.NormalEyeCoordinates, vertex3.NormalEyeCoordinates);
									short pixellightingIntensity0to255 = (short) (255f
											* LightingEquation(pixelPoint3DeyeCoordinates, pixelNormalEyeCoordinates,
													worldModel.lightPosition, worldModel.lighting_Diffuse,
													worldModel.lighting_Specular, worldModel.lighting_Ambient,
													worldModel.lighting_sHininess));
									pixelColor[0] = pixellightingIntensity0to255;
									pixelColor[1] = pixellightingIntensity0to255;
									pixelColor[2] = pixellightingIntensity0to255;
								}
							}
							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_10.ordinal()) {
								if (worldModel.displayType == DisplayTypeEnum.TEXTURE) {
									Vector2f pixelTextureCoordinates = barycentricInterpolation(
											barycentricCoordinates, vertex1.textureCoordinates,
											vertex2.textureCoordinates, vertex3.textureCoordinates);
									textureImageIntBufferWrapper.getPixel(
											(int)Math.floor(pixelTextureCoordinates.x * (textureImageIntBufferWrapper.getImageWidth()-1)), 
											(int)Math.floor(pixelTextureCoordinates.y * (textureImageIntBufferWrapper.getImageHeight()-1)), pixelColor);
								}
								if (worldModel.displayType == DisplayTypeEnum.TEXTURE_LIGHTING) {
									Vector3f pixelPoint3DeyeCoordinates = barycentricInterpolation(
											barycentricCoordinates, vertex1.point3DeyeCoordinates,
											vertex2.point3DeyeCoordinates, vertex3.point3DeyeCoordinates);
									Vector3f pixelNormalEyeCoordinates = barycentricInterpolation(
											barycentricCoordinates, vertex1.NormalEyeCoordinates,
											vertex2.NormalEyeCoordinates, vertex3.NormalEyeCoordinates);
									float pixellightingIntensity0to1 = LightingEquation(pixelPoint3DeyeCoordinates, pixelNormalEyeCoordinates,
													worldModel.lightPosition, worldModel.lighting_Diffuse,
													worldModel.lighting_Specular, worldModel.lighting_Ambient,
													worldModel.lighting_sHininess);
									Vector2f pixelTextureCoordinates = barycentricInterpolation(
											barycentricCoordinates, vertex1.textureCoordinates,
											vertex2.textureCoordinates, vertex3.textureCoordinates);
									textureImageIntBufferWrapper.getPixel(
											(int)Math.floor(pixelTextureCoordinates.x * (textureImageIntBufferWrapper.getImageWidth()-1)), 
											(int)Math.floor(pixelTextureCoordinates.y * (textureImageIntBufferWrapper.getImageHeight()-1)), pixelColor);
									pixelColor[0] = (short)(pixellightingIntensity0to1 * 1.3f * (float)pixelColor[0]);
									pixelColor[1] = (short)(pixellightingIntensity0to1 * 1.3f * (float)pixelColor[1]);
									pixelColor[2] = (short)(pixellightingIntensity0to1 * 1.3f * (float)pixelColor[2]);
								}

							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1round = Math.round(p1.x);
			int y1round = Math.round(p1.y);
			int x2round = Math.round(p2.x);
			int y2round = Math.round(p2.y);

			int x1, y1, x2, y2;
			if ((y2round - y1round) < -(x2round - x1round)
					|| ((y2round - y1round) == -(x2round - x1round)) && ((x2round - x1round) < 0)) {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			} else {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dy) <= Math.abs(dx)) {
				float a = (dx == 0) ? 0 : dy / dx; // Avoid division by zero
				float y = y1;
				int yi;
				for (int x = x1; x < x2; x++) {
					yi = Math.round(y);
					if (x >= 0 && x < imageWidth && yi >= 0 && yi < imageHeight)
						intBufferWrapper.setPixel(x, yi, r, g, b);
					y = y + a;
				}
			} else {
				float a = (dy == 0) ? 0 : dx / dy; // Avoid division by zero
				float x = x1;
				int xi;
				for (int y = y1; y < y2; y++) {
					xi = Math.round(x);
					if (xi >= 0 && xi < imageWidth && y >= 0 && y < imageHeight)
						intBufferWrapper.setPixel(xi, y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		float x = p1_property.x * barycentricCoordinates.get(0) + p2_property.x * barycentricCoordinates.get(1)
				+ p3_property.x * barycentricCoordinates.get(2);
		float y = p1_property.y * barycentricCoordinates.get(0) + p2_property.y * barycentricCoordinates.get(1)
				+ p3_property.y * barycentricCoordinates.get(2);
		return new Vector2f(x, y);
	}

	private Vector3f barycentricInterpolation(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		float x = p1_property.x * barycentricCoordinates.x + p2_property.x * barycentricCoordinates.y
				+ p3_property.x * barycentricCoordinates.z;
		float y = p1_property.y * barycentricCoordinates.x + p2_property.y * barycentricCoordinates.y
				+ p3_property.y * barycentricCoordinates.z;
		float z = p1_property.z * barycentricCoordinates.x + p2_property.z * barycentricCoordinates.y
				+ p3_property.z * barycentricCoordinates.z;
		return new Vector3f(x, y, z);
	}

	private void barycentricInterpolation(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

	float LightingEquation(Vector3f point, Vector3f PointNormal, Vector3f LightPos, float Kd, float Ks, float Ka,
			float n) {
		// Normalize point normal
		PointNormal.normalize();

		// LightDirection
		Vector3f LightDirection = new Vector3f(LightPos).sub(point).normalize();

		// EyeDirection
		Vector3f EyePos = new Vector3f(0, 0, 0);
		Vector3f EyeDirection = new Vector3f(EyePos).sub(point).normalize();

		// Calculate ReflectionDirection based on LightDirection and PointNormal
		Vector3f ReflectionDirection;
		float NdotL = PointNormal.dot(LightDirection);
		if (NdotL > 0) {
			ReflectionDirection = new Vector3f(PointNormal).mul(2.0f * NdotL).sub(LightDirection).normalize();
		} else {
			ReflectionDirection = new Vector3f(0, 0, 0);
		}


		// Diffuse component: Kd * (N · L)
		float diffuse = Math.max(0.0f, Kd * NdotL);

		// Specular component: Ks * (R · V)^n (guarding against negative R · V)
		float RdotV = Math.max(0.0f, ReflectionDirection.dot(EyeDirection));
		float specular = Ks * (float) Math.pow(RdotV, n);
		
		// Ambient component: Ka
		float ambient = Math.max(0.0f, Ka);

		// Return the sum of the components
		return diffuse + specular + ambient;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2238)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3100)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2238)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3100)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-26 16:15:32.584
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2238)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3100)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2238)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3100)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-26 16:15:32.585
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2238)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3100)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2238)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3100)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-09-26 22:03:36.360 -----------------------------------------------
eclipse.buildId=4.28.0.20230608-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2024-09-26 22:05:20.144
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-09-26 22:05:20.145
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-09-26 22:05:29.784
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\win1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-09-27 07:32:53.607 -----------------------------------------------
eclipse.buildId=4.30.0.20231201-1200
java.version=17.0.9
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.emf.ecore 2 0 2024-09-27 07:33:55.427
!MESSAGE Both 'org.eclipse.jst.j2ee.core' and 'org.eclipse.jst.j2ee.core' register a package for 'application.xmi'

!ENTRY ch.qos.logback.classic 1 0 2024-09-27 07:33:55.741
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY org.eclipse.core.resources 4 567 2024-09-27 07:34:11.173
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2024-09-27 07:34:11.173
!MESSAGE Could not read metadata for '.org.eclipse.egit.core.cmp'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/.org.eclipse.egit.core.cmp)[567]: java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:955)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:954)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:934)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:790)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1616)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2620)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2324)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:571)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:947)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:258)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:185)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:324)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:267)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:545)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:525)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:208)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:651)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:588)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1459)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2024-09-27 07:34:11.173
!MESSAGE The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:955)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:954)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:934)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:790)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1616)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2620)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2324)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:571)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:947)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:258)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:185)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:324)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:267)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:545)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:525)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:208)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:651)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:588)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1459)

!ENTRY ch.qos.logback.classic 1 0 2024-09-27 07:34:11.578
!MESSAGE Logback config file: C:\RanDocs\OneDrive - ORT Braude College of Engineering\DOK\Graphics\workspace\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.2.1.20231030-1438.xml

!ENTRY org.eclipse.jface 2 0 2024-09-27 07:34:13.965
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-09-27 07:34:13.965
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-09-27 07:34:22.163
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\rand'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-09-27 10:03:59.505 -----------------------------------------------
eclipse.buildId=4.28.0.20230608-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2024-09-27 10:04:13.475
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2024-09-27 10:04:13.475
!MESSAGE Could not read metadata for '.org.eclipse.egit.core.cmp'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/.org.eclipse.egit.core.cmp)[567]: java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:894)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:874)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:730)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2549)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2254)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:571)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:545)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:525)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2024-09-27 10:04:13.479
!MESSAGE The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:894)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:874)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:730)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2549)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2254)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:571)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:545)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:525)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2024-09-27 10:04:21.750
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-09-27 10:04:21.750
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-09-27 10:04:30.353
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\win1'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:06:36.295
!MESSAGE Failed to update meta index
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 25373 and size 1929379839
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:181)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.index.Index.getMetaIndexQualifications(Index.java:259)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager$MetaIndexUpdateRequest.execute(IndexManager.java:1789)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:514)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space
	at org.eclipse.jdt.internal.compiler.util.HashtableOfObject.<init>(HashtableOfObject.java:56)
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:682)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:181)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.index.Index.getMetaIndexQualifications(Index.java:259)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager$MetaIndexUpdateRequest.execute(IndexManager.java:1789)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:514)
	at org.eclipse.jdt.internal.core.search.processing.JobManager$$Lambda$643/0x00000001007c9238.run(Unknown Source)
	... 1 more

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:06:36.637
!MESSAGE Failed to update meta index
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 25373 and size 1929379839
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:181)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.index.Index.getMetaIndexQualifications(Index.java:259)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager$MetaIndexUpdateRequest.execute(IndexManager.java:1789)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:514)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space
	at org.eclipse.jdt.internal.compiler.util.HashtableOfObject.<init>(HashtableOfObject.java:56)
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:682)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:181)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.index.Index.getMetaIndexQualifications(Index.java:259)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager$MetaIndexUpdateRequest.execute(IndexManager.java:1789)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:514)
	at org.eclipse.jdt.internal.core.search.processing.JobManager$$Lambda$643/0x00000001007c9238.run(Unknown Source)
	... 1 more

!ENTRY org.eclipse.core.resources 4 566 2024-09-27 10:09:35.286
!MESSAGE Could not read master table.
!STACK 0
java.io.IOException: The cloud sync provider failed to validate the downloaded data
	at java.base/java.io.FileInputStream.readBytes(Native Method)
	at java.base/java.io.FileInputStream.read(FileInputStream.java:276)
	at org.eclipse.core.internal.localstore.SafeChunkyInputStream.shiftAndFillBuffer(SafeChunkyInputStream.java:178)
	at org.eclipse.core.internal.localstore.SafeChunkyInputStream.findChunkStart(SafeChunkyInputStream.java:116)
	at org.eclipse.core.internal.localstore.SafeChunkyInputStream.read(SafeChunkyInputStream.java:143)
	at java.base/java.io.InputStream.read(InputStream.java:284)
	at java.base/java.io.InputStream.read(InputStream.java:218)
	at java.base/java.util.Properties$LineReader.readLine(Properties.java:503)
	at java.base/java.util.Properties.load0(Properties.java:419)
	at java.base/java.util.Properties.load(Properties.java:408)
	at org.eclipse.core.internal.resources.SaveManager.restoreMasterTable(SaveManager.java:853)
	at org.eclipse.core.internal.resources.SaveManager.save(SaveManager.java:1248)
	at org.eclipse.core.internal.resources.SaveManager.save(SaveManager.java:1152)
	at org.eclipse.core.internal.resources.DelayedSnapshotJob.run(DelayedSnapshotJob.java:51)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:37:51.352
!MESSAGE Failed to save JDT index: Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 1148 and size 1095524163
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategory(DiskIndex.java:486)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategories(DiskIndex.java:478)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeWith(DiskIndex.java:580)
	at org.eclipse.jdt.internal.core.index.Index.save(Index.java:230)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex(IndexManager.java:1156)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndexes(IndexManager.java:1200)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.notifyIdle(IndexManager.java:838)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:494)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:37:51.782
!MESSAGE Failed to update meta index
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 25373 and size 1929379839
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:181)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.index.Index.getMetaIndexQualifications(Index.java:259)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager$MetaIndexUpdateRequest.execute(IndexManager.java:1789)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:514)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:37:52.074
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1100)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlaysWithSearchEngine(InterfaceIndicatorLabelDecorator.java:179)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlays(InterfaceIndicatorLabelDecorator.java:142)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.decorate(InterfaceIndicatorLabelDecorator.java:125)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:37:52.339
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1100)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlaysWithSearchEngine(InterfaceIndicatorLabelDecorator.java:179)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlays(InterfaceIndicatorLabelDecorator.java:142)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.decorate(InterfaceIndicatorLabelDecorator.java:125)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:37:52.597
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1100)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlaysWithSearchEngine(InterfaceIndicatorLabelDecorator.java:179)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlays(InterfaceIndicatorLabelDecorator.java:142)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.decorate(InterfaceIndicatorLabelDecorator.java:125)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:37:52.891
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1100)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlaysWithSearchEngine(InterfaceIndicatorLabelDecorator.java:179)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlays(InterfaceIndicatorLabelDecorator.java:142)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.decorate(InterfaceIndicatorLabelDecorator.java:125)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:37:53.150
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1100)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlaysWithSearchEngine(InterfaceIndicatorLabelDecorator.java:179)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlays(InterfaceIndicatorLabelDecorator.java:142)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.decorate(InterfaceIndicatorLabelDecorator.java:125)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:37:53.403
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1100)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlaysWithSearchEngine(InterfaceIndicatorLabelDecorator.java:179)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlays(InterfaceIndicatorLabelDecorator.java:142)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.decorate(InterfaceIndicatorLabelDecorator.java:125)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:37:53.646
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1100)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlaysWithSearchEngine(InterfaceIndicatorLabelDecorator.java:179)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlays(InterfaceIndicatorLabelDecorator.java:142)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.decorate(InterfaceIndicatorLabelDecorator.java:125)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:37:53.887
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1100)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlaysWithSearchEngine(InterfaceIndicatorLabelDecorator.java:179)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlays(InterfaceIndicatorLabelDecorator.java:142)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.decorate(InterfaceIndicatorLabelDecorator.java:125)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:37:54.142
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1100)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlaysWithSearchEngine(InterfaceIndicatorLabelDecorator.java:179)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlays(InterfaceIndicatorLabelDecorator.java:142)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.decorate(InterfaceIndicatorLabelDecorator.java:125)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:37:54.387
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1100)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlaysWithSearchEngine(InterfaceIndicatorLabelDecorator.java:179)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlays(InterfaceIndicatorLabelDecorator.java:142)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.decorate(InterfaceIndicatorLabelDecorator.java:125)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:38:41.020
!MESSAGE Failed to save JDT index: Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 1148 and size 1095524163
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategory(DiskIndex.java:486)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategories(DiskIndex.java:478)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeWith(DiskIndex.java:580)
	at org.eclipse.jdt.internal.core.index.Index.save(Index.java:230)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex(IndexManager.java:1156)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndexes(IndexManager.java:1200)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.notifyIdle(IndexManager.java:838)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:494)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:38:41.712
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1100)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlaysWithSearchEngine(InterfaceIndicatorLabelDecorator.java:179)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.addOverlays(InterfaceIndicatorLabelDecorator.java:142)
	at org.eclipse.jdt.internal.ui.InterfaceIndicatorLabelDecorator.decorate(InterfaceIndicatorLabelDecorator.java:125)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.core.jobs 4 2 2024-09-27 10:42:53.227
!MESSAGE An internal error occurred during: "Periodic workspace save.".
!STACK 0
java.lang.NumberFormatException: Cannot parse null string
	at java.base/java.lang.Integer.parseInt(Integer.java:630)
	at java.base/java.lang.Integer.parseInt(Integer.java:786)
	at org.eclipse.core.internal.resources.SaveManager.validateMasterTableBeforeSave(SaveManager.java:1618)
	at org.eclipse.core.internal.resources.SaveManager.saveMasterTable(SaveManager.java:1277)
	at org.eclipse.core.internal.resources.SaveManager.saveMasterTable(SaveManager.java:1268)
	at org.eclipse.core.internal.resources.SaveManager.save(SaveManager.java:1241)
	at org.eclipse.core.internal.resources.SaveManager.save(SaveManager.java:1152)
	at org.eclipse.core.internal.resources.DelayedSnapshotJob.run(DelayedSnapshotJob.java:51)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:53:58.279
!MESSAGE Failed to save JDT index: Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 1148 and size 1095524163
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategory(DiskIndex.java:486)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategories(DiskIndex.java:478)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeWith(DiskIndex.java:580)
	at org.eclipse.jdt.internal.core.index.Index.save(Index.java:230)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex(IndexManager.java:1156)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndexes(IndexManager.java:1200)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.notifyIdle(IndexManager.java:838)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:494)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:53:59.558
!MESSAGE Failed to update meta index
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 25373 and size 1929379839
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:181)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.index.Index.getMetaIndexQualifications(Index.java:259)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager$MetaIndexUpdateRequest.execute(IndexManager.java:1789)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:514)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:54:41.649
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.MultiTypeDeclarationPattern.queryIn(MultiTypeDeclarationPattern.java:150)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:2175)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1299)
	at org.eclipse.jdt.core.manipulation.OrganizeImportsOperation$TypeReferenceProcessor.process(OrganizeImportsOperation.java:364)
	at org.eclipse.jdt.core.manipulation.OrganizeImportsOperation.createTextEdit(OrganizeImportsOperation.java:617)
	at org.eclipse.jdt.core.manipulation.OrganizeImportsOperation.run(OrganizeImportsOperation.java:568)
	at org.eclipse.jdt.ui.actions.OrganizeImportsAction$1.run(OrganizeImportsAction.java:298)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:54:47.149
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.MultiTypeDeclarationPattern.queryIn(MultiTypeDeclarationPattern.java:150)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:2175)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1299)
	at org.eclipse.jdt.core.manipulation.OrganizeImportsOperation$TypeReferenceProcessor.process(OrganizeImportsOperation.java:364)
	at org.eclipse.jdt.core.manipulation.OrganizeImportsOperation.createTextEdit(OrganizeImportsOperation.java:617)
	at org.eclipse.jdt.core.manipulation.OrganizeImportsOperation.run(OrganizeImportsOperation.java:568)
	at org.eclipse.jdt.ui.actions.OrganizeImportsAction$1.run(OrganizeImportsAction.java:298)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:55:38.315
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 10:55:41.501
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:703)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.findImports(CompletionEngine.java:8665)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:2290)
	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:136)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357)
	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.internalComputeCompletionProposals(JavaCompletionProposalComputer.java:256)
	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.computeCompletionProposals(JavaCompletionProposalComputer.java:218)
	at org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposalComputer.computeCompletionProposals(JavaTypeCompletionProposalComputer.java:65)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:348)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.ContentAssistant$2.lambda$0(ContentAssistant.java:2063)
	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4905)
	at org.eclipse.jface.text.contentassist.ContentAssistant$2.run(ContentAssistant.java:2062)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:2059)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:577)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.lambda$0(CompletionProposalPopup.java:507)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:502)
	at org.eclipse.jface.text.contentassist.ContentAssistant$AutoAssistListener.lambda$0(ContentAssistant.java:399)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4047)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3663)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.core.jobs 4 2 2024-09-27 10:58:53.017
!MESSAGE An internal error occurred during: "Periodic workspace save.".
!STACK 0
java.lang.NumberFormatException: Cannot parse null string
	at java.base/java.lang.Integer.parseInt(Integer.java:630)
	at java.base/java.lang.Integer.parseInt(Integer.java:786)
	at org.eclipse.core.internal.resources.SaveManager.validateMasterTableBeforeSave(SaveManager.java:1618)
	at org.eclipse.core.internal.resources.SaveManager.saveMasterTable(SaveManager.java:1277)
	at org.eclipse.core.internal.resources.SaveManager.saveMasterTable(SaveManager.java:1268)
	at org.eclipse.core.internal.resources.SaveManager.save(SaveManager.java:1241)
	at org.eclipse.core.internal.resources.SaveManager.save(SaveManager.java:1152)
	at org.eclipse.core.internal.resources.DelayedSnapshotJob.run(DelayedSnapshotJob.java:51)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:01:48.404
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:747)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:585)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:564)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1106)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:121)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:667)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:663)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:01:48.802
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:01:49.221
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:01:49.617
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:02:43.342
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:02:43.726
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:02:44.098
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:747)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:585)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:564)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1106)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:121)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo(JavaSourceHover.java:140)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo2(JavaSourceHover.java:127)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:02:44.469
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:04:04.500
!MESSAGE Failed to save JDT index: Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 1148 and size 1095524163
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategory(DiskIndex.java:486)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategories(DiskIndex.java:478)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeWith(DiskIndex.java:580)
	at org.eclipse.jdt.internal.core.index.Index.save(Index.java:230)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex(IndexManager.java:1156)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndexes(IndexManager.java:1200)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.notifyIdle(IndexManager.java:838)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:494)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:04:05.407
!MESSAGE Failed to update meta index
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 25373 and size 1929379839
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:181)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.index.Index.getMetaIndexQualifications(Index.java:259)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager$MetaIndexUpdateRequest.execute(IndexManager.java:1789)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:514)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:04:35.018
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:04:35.428
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:04:35.812
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:05:12.478
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:747)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:585)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:564)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1106)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.resolveElement(JavaDebugHover.java:520)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:303)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:05:12.899
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:05:13.634
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:747)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:585)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:564)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1106)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:121)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:667)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:663)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:05:14.061
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:05:14.457
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:747)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:585)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:564)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1106)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:121)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo(JavaSourceHover.java:140)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo2(JavaSourceHover.java:127)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:05:14.867
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.findAllTypes(SelectionEngine.java:913)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1114)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:121)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo(JavaSourceHover.java:140)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo2(JavaSourceHover.java:127)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:06:16.686
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:06:17.090
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:06:17.490
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:06:46.647
!MESSAGE Failed to save JDT index: Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 1148 and size 1095524163
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategory(DiskIndex.java:486)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategories(DiskIndex.java:478)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeWith(DiskIndex.java:580)
	at org.eclipse.jdt.internal.core.index.Index.save(Index.java:230)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex(IndexManager.java:1156)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndexes(IndexManager.java:1200)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.notifyIdle(IndexManager.java:838)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:494)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:06:47.182
!MESSAGE Failed to update meta index
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 25373 and size 1929379839
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:181)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.index.Index.getMetaIndexQualifications(Index.java:259)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager$MetaIndexUpdateRequest.execute(IndexManager.java:1789)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:514)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:06:47.579
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1202)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.hasMultipleMatchesInWorkspace(JDIDebugTarget.java:1595)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsResource(JDIDebugTarget.java:1437)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1387)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointAdded(JDIDebugTarget.java:1626)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.initializeBreakpoints(JDIDebugTarget.java:631)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.initialize(JDIDebugTarget.java:558)
	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.<init>(JDIDebugTarget.java:380)
	at org.eclipse.jdt.debug.core.JDIDebugModel.lambda$0(JDIDebugModel.java:239)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2382)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2407)
	at org.eclipse.jdt.debug.core.JDIDebugModel.newDebugTarget(JDIDebugModel.java:241)
	at org.eclipse.jdt.internal.launching.StandardVMDebugger.createDebugTarget(StandardVMDebugger.java:552)
	at org.eclipse.jdt.internal.launching.StandardVMDebugger.run(StandardVMDebugger.java:424)
	at org.eclipse.jdt.launching.JavaLaunchDelegate.launch(JavaLaunchDelegate.java:176)
	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:806)
	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:717)
	at org.eclipse.debug.internal.ui.DebugUIPlugin.buildAndLaunch(DebugUIPlugin.java:1040)
	at org.eclipse.debug.internal.ui.DebugUIPlugin$1.run(DebugUIPlugin.java:1243)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:06:47.961
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:06:48.343
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:08:58.679
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:747)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:585)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:564)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1106)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:121)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:667)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:663)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:08:59.101
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:08:59.539
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:747)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:585)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:564)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1106)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:121)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo(JavaSourceHover.java:140)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo2(JavaSourceHover.java:127)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:08:59.993
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.findAllTypes(SelectionEngine.java:913)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1114)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:121)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo(JavaSourceHover.java:140)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaSourceHover.getHoverInfo2(JavaSourceHover.java:127)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.core.jobs 4 2 2024-09-27 11:09:04.146
!MESSAGE An internal error occurred during: "Periodic workspace save.".
!STACK 0
java.lang.NumberFormatException: Cannot parse null string
	at java.base/java.lang.Integer.parseInt(Integer.java:630)
	at java.base/java.lang.Integer.parseInt(Integer.java:786)
	at org.eclipse.core.internal.resources.SaveManager.validateMasterTableBeforeSave(SaveManager.java:1618)
	at org.eclipse.core.internal.resources.SaveManager.saveMasterTable(SaveManager.java:1277)
	at org.eclipse.core.internal.resources.SaveManager.saveMasterTable(SaveManager.java:1268)
	at org.eclipse.core.internal.resources.SaveManager.save(SaveManager.java:1241)
	at org.eclipse.core.internal.resources.SaveManager.save(SaveManager.java:1152)
	at org.eclipse.core.internal.resources.DelayedSnapshotJob.run(DelayedSnapshotJob.java:51)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:09:49.188
!MESSAGE Failed to save JDT index: Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 1148 and size 1095524163
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategory(DiskIndex.java:486)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategories(DiskIndex.java:478)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeWith(DiskIndex.java:580)
	at org.eclipse.jdt.internal.core.index.Index.save(Index.java:230)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex(IndexManager.java:1156)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndexes(IndexManager.java:1200)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.notifyIdle(IndexManager.java:838)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:494)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:09:50.155
!MESSAGE Failed to update meta index
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 25373 and size 1929379839
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:181)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.index.Index.getMetaIndexQualifications(Index.java:259)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager$MetaIndexUpdateRequest.execute(IndexManager.java:1789)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:514)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:09:59.930
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:703)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.findTypesAndPackages(CompletionEngine.java:11896)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.completionOnSingleNameReference(CompletionEngine.java:4017)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:2017)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:2356)
	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:136)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:367)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357)
	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.internalComputeCompletionProposals(JavaCompletionProposalComputer.java:256)
	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.computeCompletionProposals(JavaCompletionProposalComputer.java:218)
	at org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposalComputer.computeCompletionProposals(JavaTypeCompletionProposalComputer.java:65)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:348)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:340)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:289)
	at org.eclipse.jface.text.contentassist.ContentAssistant$2.lambda$0(ContentAssistant.java:2063)
	at java.base/java.util.Collections$SingletonSet.forEach(Collections.java:4905)
	at org.eclipse.jface.text.contentassist.ContentAssistant$2.run(ContentAssistant.java:2062)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:2059)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:577)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1546)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:367)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4047)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3663)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:10:52.141
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:747)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:585)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:564)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1106)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:124)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:10:52.531
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:10:52.942
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:747)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:585)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:564)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1106)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.xtext.common.types.ui.navigation.LinkToOriginDetector.detectHyperlinks(LinkToOriginDetector.java:72)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:10:53.335
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:11:08.982
!MESSAGE Failed to save JDT index: Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 1148 and size 1095524163
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategory(DiskIndex.java:486)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategories(DiskIndex.java:478)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeWith(DiskIndex.java:580)
	at org.eclipse.jdt.internal.core.index.Index.save(Index.java:230)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex(IndexManager.java:1156)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndexes(IndexManager.java:1200)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.notifyIdle(IndexManager.java:838)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:494)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:11:09.894
!MESSAGE Failed to update meta index
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 25373 and size 1929379839
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:181)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.index.Index.getMetaIndexQualifications(Index.java:259)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager$MetaIndexUpdateRequest.execute(IndexManager.java:1789)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:514)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:11:28.597
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 4039 and size 1768846380
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:199)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.MethodPattern.queryIn(MethodPattern.java:363)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:235)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:602)
	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:670)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:98)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:167)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:11:29.121
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 23651 and size 822083583
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.SuperTypeReferencePattern.queryIn(SuperTypeReferencePattern.java:280)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.SubTypeSearchJob.search(SubTypeSearchJob.java:63)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.legacySearchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:605)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.searchAllPossibleSubTypes(IndexBasedHierarchyBuilder.java:506)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.determinePossibleSubTypes(IndexBasedHierarchyBuilder.java:465)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:158)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:323)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1319)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:950)
	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:907)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.addSubtypes(MainMethodSearchEngine.java:130)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine.searchMainMethods(MainMethodSearchEngine.java:107)
	at org.eclipse.jdt.internal.debug.ui.launcher.MainMethodSearchEngine$1.run(MainMethodSearchEngine.java:167)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:11:31.244
!MESSAGE Failed to save JDT index: Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 1148 and size 1095524163
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategory(DiskIndex.java:486)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategories(DiskIndex.java:478)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeWith(DiskIndex.java:580)
	at org.eclipse.jdt.internal.core.index.Index.save(Index.java:230)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex(IndexManager.java:1156)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndexes(IndexManager.java:1200)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.notifyIdle(IndexManager.java:838)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:494)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:11:32.195
!MESSAGE Failed to update meta index
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 25373 and size 1929379839
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:181)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.index.Index.getMetaIndexQualifications(Index.java:259)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager$MetaIndexUpdateRequest.execute(IndexManager.java:1789)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:514)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:11:51.888
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.MultiTypeDeclarationPattern.queryIn(MultiTypeDeclarationPattern.java:150)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:11:52.289
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:14:36.056
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:747)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:585)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:564)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1106)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:124)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:14:36.539
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.findAllTypes(SelectionEngine.java:913)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1114)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:124)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:14:36.956
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:747)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:585)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:564)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1106)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.xtext.common.types.ui.navigation.LinkToOriginDetector.detectHyperlinks(LinkToOriginDetector.java:72)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:14:37.397
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.findAllTypes(SelectionEngine.java:913)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1114)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.xtext.common.types.ui.navigation.LinkToOriginDetector.detectHyperlinks(LinkToOriginDetector.java:72)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:14:41.860
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:747)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:585)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:564)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1106)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:124)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:14:42.295
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1751)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.findAllTypes(SelectionEngine.java:913)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1114)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:124)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:14:42.729
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:239)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinTask.awaitDone(ForkJoinTask.java:436)
	at java.base/java.util.concurrent.ForkJoinTask.get(ForkJoinTask.java:979)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.performParallelSearch(PatternSearchJob.java:154)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:115)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:371)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1923)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:747)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:585)
	at org.eclipse.jdt.internal.core.SearchableEnvironment.findTypes(SearchableEnvironment.java:564)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1106)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.xtext.common.types.ui.navigation.LinkToOriginDetector.detectHyperlinks(LinkToOriginDetector.java:72)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:14:43.125
!MESSAGE Search failed for index Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 13736 and size 1699766644
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:208)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern.queryIn(TypeDeclarationPattern.java:364)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2517)
	at org.eclipse.jdt.core.search.SearchPattern.findIndexMatches(SearchPattern.java:2489)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.findIndexMatches(MatchLocator.java:306)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:238)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.search(PatternSearchJob.java:212)
	at org.eclipse.jdt.internal.core.search.PatternSearchJob.lambda$0(PatternSearchJob.java:148)
	at java.base/java.util.concurrent.ForkJoinTask$AdaptedCallable.exec(ForkJoinTask.java:1428)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.core.jobs 4 2 2024-09-27 11:14:48.818
!MESSAGE An internal error occurred during: "Periodic workspace save.".
!STACK 0
java.lang.NumberFormatException: Cannot parse null string
	at java.base/java.lang.Integer.parseInt(Integer.java:630)
	at java.base/java.lang.Integer.parseInt(Integer.java:786)
	at org.eclipse.core.internal.resources.SaveManager.validateMasterTableBeforeSave(SaveManager.java:1618)
	at org.eclipse.core.internal.resources.SaveManager.saveMasterTable(SaveManager.java:1277)
	at org.eclipse.core.internal.resources.SaveManager.saveMasterTable(SaveManager.java:1268)
	at org.eclipse.core.internal.resources.SaveManager.save(SaveManager.java:1241)
	at org.eclipse.core.internal.resources.SaveManager.save(SaveManager.java:1152)
	at org.eclipse.core.internal.resources.DelayedSnapshotJob.run(DelayedSnapshotJob.java:51)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:15:14.593
!MESSAGE Failed to save JDT index: Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 1148 and size 1095524163
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategory(DiskIndex.java:486)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategories(DiskIndex.java:478)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeWith(DiskIndex.java:580)
	at org.eclipse.jdt.internal.core.index.Index.save(Index.java:230)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex(IndexManager.java:1156)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndexes(IndexManager.java:1200)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.notifyIdle(IndexManager.java:838)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:494)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:15:15.874
!MESSAGE Failed to update meta index
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 25373 and size 1929379839
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:181)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.index.Index.getMetaIndexQualifications(Index.java:259)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager$MetaIndexUpdateRequest.execute(IndexManager.java:1789)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:514)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:17:20.024
!MESSAGE Failed to save JDT index: Index for /RayTracing
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 1148 and size 1095524163
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategory(DiskIndex.java:486)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeCategories(DiskIndex.java:478)
	at org.eclipse.jdt.internal.core.index.DiskIndex.mergeWith(DiskIndex.java:580)
	at org.eclipse.jdt.internal.core.index.Index.save(Index.java:230)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndex(IndexManager.java:1156)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.saveIndexes(IndexManager.java:1200)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.notifyIdle(IndexManager.java:838)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:494)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.jdt.core 4 4 2024-09-27 11:17:21.110
!MESSAGE Failed to update meta index
!STACK 0
java.io.IOException: Failed to read index data from file:/D:/My_Documents/OneDrive%20-%20ORT%20Braude%20College%20of%20Engineering/DOK/Graphics/workspace/.metadata/.plugins/org.eclipse.jdt.core/802853413.index at offset 25373 and size 1929379839
	at org.eclipse.jdt.internal.core.index.DiskIndex.readCategoryTable(DiskIndex.java:686)
	at org.eclipse.jdt.internal.core.index.DiskIndex.addQueryResults(DiskIndex.java:181)
	at org.eclipse.jdt.internal.core.index.Index.query(Index.java:169)
	at org.eclipse.jdt.internal.core.index.Index.getMetaIndexQualifications(Index.java:259)
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager$MetaIndexUpdateRequest.execute(IndexManager.java:1789)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.indexerLoop(JobManager.java:514)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.OutOfMemoryError: Java heap space

!ENTRY org.eclipse.core.jobs 4 2 2024-09-27 11:20:14.085
!MESSAGE An internal error occurred during: "Periodic workspace save.".
!STACK 0
java.lang.NumberFormatException: Cannot parse null string
	at java.base/java.lang.Integer.parseInt(Integer.java:630)
	at java.base/java.lang.Integer.parseInt(Integer.java:786)
	at org.eclipse.core.internal.resources.SaveManager.validateMasterTableBeforeSave(SaveManager.java:1618)
	at org.eclipse.core.internal.resources.SaveManager.saveMasterTable(SaveManager.java:1277)
	at org.eclipse.core.internal.resources.SaveManager.saveMasterTable(SaveManager.java:1268)
	at org.eclipse.core.internal.resources.SaveManager.save(SaveManager.java:1241)
	at org.eclipse.core.internal.resources.SaveManager.save(SaveManager.java:1152)
	at org.eclipse.core.internal.resources.DelayedSnapshotJob.run(DelayedSnapshotJob.java:51)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui.ide 4 4 2024-09-27 11:21:37.219
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:668)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:300)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:103)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:72)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImage(ResourceManager.java:175)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.getImage(AbstractContributionItem.java:151)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.updateIcons(AbstractContributionItem.java:177)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.update(AbstractContributionItem.java:127)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.fill(AbstractContributionItem.java:264)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at jdk.internal.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:105)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:191)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:202)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:256)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:114)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
