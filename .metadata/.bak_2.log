!SESSION 2024-09-25 08:56:29.816 -----------------------------------------------
eclipse.buildId=4.28.0.20230608-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file D:\My_Documents\OneDrive - ORT Braude College of Engineering\DOK\Graphics\workspace\.metadata\.bak_1.log
Created Time: 2024-09-25 11:29:11.163

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:11.163
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:11.165
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:14.918
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:14.919
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:14.919
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:15.807
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewMe = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:29:15.808
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:29:15.809
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:15.961
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewMe = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:15.962
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:15.963
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:17.185
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:29:17.186
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:29:17.186
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:17.355
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:17.355
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:17.356
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:19.385
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:29:19.386
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:29:19.387
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:19.474
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:29:19.474
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:29:19.475
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:19.497
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:19.498
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:19.498
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:22.398
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:22.399
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:22.400
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:23.235
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix4f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:23.236
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:23.237
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:27.177
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix24f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:29:27.178
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:29:27.179
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:27.395
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix24f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:27.405
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:27.406
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:28.857
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix34f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:29:28.859
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:29:28.860
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:31.081
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix3f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:29:31.082
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:29:31.083
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:31.281
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix3f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:31.282
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:31.290
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:33.745
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix3f().identity();
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:33.746
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:33.747
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:34.439
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix3f
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:29:34.440
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:29:34.441
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:34.549
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix3f
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:34.554
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:34.555
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:35.345
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix3f;
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:29:35.346
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:29:35.347
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:35.517
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix3f;
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:35.518
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:35.519
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:38.243
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix3f;
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:38.244
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:38.245
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:41.605
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix3f;
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:41.612
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:41.612
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:45.187
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix3f;
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:45.188
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:45.189
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:45.953
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			modelviewM
			Matrix3f modelviewM3x3 = new Matrix3f;
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:309)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:243)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:655)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.internal.BidiUtil.windowProc(BidiUtil.java:663)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:45.955
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:309)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:243)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:655)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.internal.BidiUtil.windowProc(BidiUtil.java:663)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:45.966
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:309)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:243)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:655)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.internal.BidiUtil.windowProc(BidiUtil.java:663)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:46.564
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:29:46.565
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:29:46.566
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:47.422
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:29:47.422
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:29:47.423
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:47.501
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:47.503
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:47.504
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:48.221
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:48.222
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:48.223
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:49.406
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:49.407
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:49.407
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:51.856
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:29:51.857
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:29:51.858
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:51.945
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:51.946
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:51.947
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:53.943
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:29:53.943
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:29:53.944
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:54.113
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:29:54.114
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:29:54.114
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:29:58.596
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(null)
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:29:58.598
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:29:58.600
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:30:06.478
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3)
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:30:06.479
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:30:06.479
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:30:07.707
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:30:07.708
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:30:07.709
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:30:07.817
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:30:07.818
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:30:07.819
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:30:08.943
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:30:08.944
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:30:08.945
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:30:12.245
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			glm::mat3 Mmodeling3x3;
			glm::mat3 Mlookat3x3;
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:30:12.246
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:30:12.247
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:30:14.400
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2024-09-25 11:30:14.401
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2024-09-25 11:30:14.402
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:30:14.617
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:30:14.619
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:30:14.619
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:30:26.023
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:30:26.025
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:30:26.027
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-09-25 11:30:28.861
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package your_code;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.joml.Matrix4f;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

import rasterization_app.DisplayTypeEnum;
import rasterization_app.ExerciseEnum;
import rasterization_app.IntBufferWrapper;
import rasterization_app.OBJLoader;

public class ObjectModel {
	WorldModel worldModel;

	private int imageWidth;
	private int imageHeight;

	private List<Vertex> vertices;
	private List<TriangleFace> faces;

	private Matrix4f modelM = new Matrix4f().identity();
	private Matrix4f lookatM = new Matrix4f().identity();
	private Matrix4f modelviewM = new Matrix4f().identity();
	private Matrix4f projectionM = new Matrix4f().identity();
	private Matrix4f viewportM = new Matrix4f().identity();
	private Vector3f boundingBoxDimensions;
	private Vector3f boundingBoxCenter;

	public ObjectModel(WorldModel worldModel, int imageWidth, int imageHeight) {
		this.worldModel = worldModel;
		this.imageWidth = imageWidth;
		this.imageHeight = imageHeight;
	}

	void setModelM(Matrix4f modelM) {
		this.modelM = modelM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setLookatM(Matrix4f lookatM) {
		this.lookatM = lookatM;
		modelviewM = new Matrix4f(lookatM).mul(modelM);
	}

	void setProjectionM(Matrix4f projectionM) {
		this.projectionM = projectionM;
	}

	void setViewportM(Matrix4f viewportM) {
		this.viewportM = viewportM;
	}

	public Vector3f getBoundingBoxDimensions() {
		return boundingBoxDimensions;
	}

	public Vector3f getBoundingBoxCenter() {
		return boundingBoxCenter;
	}

	public boolean load(String fileName) {
		OBJLoader objLoader = new OBJLoader();
		System.out.println("Model class read the file " + fileName);
		try {
			objLoader.loadOBJ(fileName);
			vertices = objLoader.getVertices();
			faces = objLoader.getFaces();
			boundingBoxDimensions = objLoader.getBoundingBoxDimensions();
			boundingBoxCenter = objLoader.getBoundingBoxCenter();
			return true;
		} catch (IOException e) {
			System.err.println("Failed to load the OBJ file.");
			return false;
		}
	}

	public void render(IntBufferWrapper intBufferWrapper, float[][] zBuffer) {
		if (vertices != null) {
			for (Vertex vertex : vertices) {
				// System.out.println("Position: " + vertex.position + ", Normal: " +
				// vertex.normal + ", Texture: " + vertex.textureCoord);
				vertexProcessing(vertex);
			}
			for (TriangleFace face : faces) {
				// System.out.println("Indices: " + Arrays.toString(face.indices) + ", Color: "
				// + face.color);
				faceProcessing(intBufferWrapper, vertices.get(face.indices[0]), vertices.get(face.indices[1]),
						vertices.get(face.indices[2]), face.color);
			}
		}
	}

	public void vertexProcessing(Vertex vertex) {
//		System.out.println(vertex.point3D);
//		System.out.println(Arrays.toString(vertex.color));
//		System.out.println();

		// Initialize a 4D vector from the 3D vertex point
		Vector4f v = new Vector4f(vertex.point3D, 1f);

		// Transform to eye coordinates (model-view transformation)
		modelviewM.transform(v);
		vertex.point3DeyeCoordinates = new Vector3f(v.x, v.y, v.z);

		// Apply projection transformation
		projectionM.transform(v);

		// Perspective divide if w is non-zero
		if (v.w != 0) {
			v.mul(1 / v.w);
		} else {
			System.err.println("Division by w == 0 in vertexProcessing");
		}

		// Apply viewport transformation and set screen point
		viewportM.transform(v);
		vertex.pointScreen = new Vector3f(v.x, v.y, v.z);

		if (worldModel.displayNormals) {
			// transformation normal from object coordinates to eye coordinates v->normal --> v->NormalEyeCoordinates
			Matrix3f modelviewM3x3 = new Matrix3f;
			modelviewM.get3x3(modelviewM3x3);
			
			glm::vec3 temp13;
			Mmodeling3x3 = glm::mat3(Mmodeling);
			Mlookat3x3 = glm::mat3(Mlookat);
			v.NormalEyeCoordinates = glm::normalize(glm::vec4(Mlookat3x3 * Mmodeling3x3 * glm::vec3(v.normal), 1));

			//drawing normals 
			Vector4f temp2;
			Vector4f point3D_plusNormal_screen;
//			v.point3DeyeCoordinates = v.point3DeyeCoordinates / v.point3DeyeCoordinates[3];
			Vector4f temp13 = vertex.normal 
					v.NormalEyeCoordinates * (float)0.05;
//			temp13 = v.NormalEyeCoordinates * (float)0.05;
//			temp2 = v.point3DeyeCoordinates + glm::vec4(temp13, 1);
//			temp2[3] = 1;
//			point3D_plusNormal_screen = Mviewport * Mprojection * temp2;
//			point3D_plusNormal_screen = point3D_plusNormal_screen / point3D_plusNormal_screen[3];
//			v.pointScreen = v.pointScreen / v.pointScreen[3];
			drawLineDDA(intBufferWrapper, vertex.pointScreen, point3D_plusNormal_screen, 0, 0, 255);
		}		
	}

	public void faceProcessing(IntBufferWrapper intBufferWrapper, Vertex vertex1, Vertex vertex2, Vertex vertex3,
			short[] faceColor) {
		short[] pixelColor = new short[3];

		// for debugging you can use intBufferWrapper.saveToBMP("output.bmp"); in the
		// Debug Shell or saveToCSV

		if (worldModel.exercise == ExerciseEnum.EX_0) {
			intBufferWrapper.setPixel((int) vertex1.pointScreen.x, (int) vertex1.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex2.pointScreen.x, (int) vertex2.pointScreen.y, 255, 255, 255);
			intBufferWrapper.setPixel((int) vertex3.pointScreen.x, (int) vertex3.pointScreen.y, 255, 255, 255);
		}

		if (worldModel.displayType == DisplayTypeEnum.FACE_EDGES) {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
				drawLineDDA(intBufferWrapper, vertex1.pointScreen, vertex2.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex2.pointScreen, vertex3.pointScreen, 255, 255, 255);
				drawLineDDA(intBufferWrapper, vertex3.pointScreen, vertex1.pointScreen, 255, 255, 255);
			}
		} else {
			if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_2.ordinal()) {
				Vector3f LineOppositeToV1 = lineFrom2Points(vertex2.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV2 = lineFrom2Points(vertex1.pointScreen, vertex3.pointScreen);
				Vector3f LineOppositeToV3 = lineFrom2Points(vertex1.pointScreen, vertex2.pointScreen);
				float V1distanceToLine = distanceOfPointFromLine(LineOppositeToV1, vertex1.pointScreen);
				float V2distanceToLine = distanceOfPointFromLine(LineOppositeToV2, vertex2.pointScreen);
				float V3distanceToLine = distanceOfPointFromLine(LineOppositeToV3, vertex3.pointScreen);

				int minX = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int minY = (int) Math.floor(Math.max(0.0f, (float) Math.floor(
						Math.min(Math.min(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				int maxX = (int) Math.ceil(Math.min((float) imageWidth - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.x, vertex2.pointScreen.x), vertex3.pointScreen.x))));
				int maxY = (int) Math.ceil(Math.min((float) imageHeight - 1, (float) Math.ceil(
						Math.max(Math.max(vertex1.pointScreen.y, vertex2.pointScreen.y), vertex3.pointScreen.y))));
				for (int x = minX; x <= maxX; x++) {
					for (int y = minY; y <= maxY; y++) {
						Vector2f currentPoint = new Vector2f(x, y);
						float BarycentricAlfa = distanceOfPointFromLine(LineOppositeToV1, currentPoint)
								/ V1distanceToLine;
						float BarycentricBeta = distanceOfPointFromLine(LineOppositeToV2, currentPoint)
								/ V2distanceToLine;
						float BarycentricGama = distanceOfPointFromLine(LineOppositeToV3, currentPoint)
								/ V3distanceToLine;
						Vector3f barycentricCoordinates = new Vector3f(BarycentricAlfa, BarycentricBeta,
								BarycentricGama);
						barycentricCoordinates.mul(1.0f
								/ (barycentricCoordinates.x + barycentricCoordinates.y + barycentricCoordinates.z));
						// System.out.println(barycentricCoordinates.x + barycentricCoordinates.y +
						// barycentricCoordinates.z);

						if ((barycentricCoordinates.get(0) >= 0) && (barycentricCoordinates.get(1) >= 0)
								&& (barycentricCoordinates.get(2) >= 0) && (barycentricCoordinates.get(0) <= 1)
								&& (barycentricCoordinates.get(1) <= 1) && (barycentricCoordinates.get(2) <= 1)) {
							if (worldModel.displayType == DisplayTypeEnum.FACE_COLOR) {
								pixelColor[0] = faceColor[0];
								pixelColor[1] = faceColor[1];
								pixelColor[2] = faceColor[2];
							}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_7.ordinal())
								if (worldModel.displayType == DisplayTypeEnum.INTERPOlATED_VERTEX_COLOR) {
									barycentricInterpolation_color(barycentricCoordinates, vertex1.color, vertex2.color,
											vertex3.color, pixelColor);
//									pixelColor[0] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[1] = (short)Math.round(barycentricCoordinates.y*255);
//									pixelColor[2] = (short)Math.round(barycentricCoordinates.y*255);
								}

							if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_8.ordinal()) {
								float pixelZ = barycentricInterpolation_f(barycentricCoordinates, vertex1.pointScreen.z,
										vertex2.pointScreen.z, vertex3.pointScreen.z);
								if (pixelZ < worldModel.zBuffer[y][x]) {
									worldModel.zBuffer[y][x] = pixelZ;
									intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
								}
							} else
								intBufferWrapper.setPixel((int) currentPoint.x, (int) currentPoint.y, pixelColor);
						}

					}
				}
			}
		}

	}

	private void drawLineDDA(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int x1, y1, x2, y2;
			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = (int) p1.x;
				y1 = (int) p1.y;
				x2 = (int) p2.x;
				y2 = (int) p2.y;
			} else {
				x1 = (int) p2.x;
				y1 = (int) p2.y;
				x2 = (int) p1.x;
				y2 = (int) p1.y;
			}

			float dx = x2 - x1;
			float dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				float a = dy / dx;
				float y = y1;
				for (int x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, Math.round(y), r, g, b);
					y = y + a;
				}
			} else {
				float a = dx / dy;
				float x = x1;
				for (int y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(Math.round(x), y, r, g, b);
					x = x + a;
				}
			}
		}
	}

	private void drawLineBresenham(IntBufferWrapper intBufferWrapper, Vector3f p1, Vector3f p2, int r, int g, int b) {
		if (worldModel.exercise.ordinal() >= ExerciseEnum.EX_1.ordinal()) {
			int dx, dy, x, y, x1, y1, x2, y2, diff, yIncrement, xIncrement;

			if ((p2.y - p1.y) > -(p2.x - p1.x)) {
				x1 = Math.round(p1.x);
				y1 = Math.round(p1.y);
				x2 = Math.round(p2.x);
				y2 = Math.round(p2.y);
			} else {
				x1 = Math.round(p2.x);
				y1 = Math.round(p2.y);
				x2 = Math.round(p1.x);
				y2 = Math.round(p1.y);
			}

			dx = x2 - x1;
			dy = y2 - y1;
			if (Math.abs(dx) > Math.abs(dy)) {
				diff = 2 * dy - dx;
				yIncrement = 1;
				if (dy < 0) {
					yIncrement = -1;
					dy = -dy;
				}
				y = y1;
				for (x = x1; x < x2; x++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dy;
					} else {
						y += yIncrement;
						diff += 2 * dy - 2 * dx;
					}
				}
			} else {
				diff = 2 * dx - dy;
				xIncrement = 1;
				if (dx < 0) {
					xIncrement = -1;
					dx = -dx;
				}
				x = x1;
				for (y = y1; y < y2; y++) {
					intBufferWrapper.setPixel(x, y, r, g, b);
					if (diff < 0) {
						diff += 2 * dx;
					} else {
						x += xIncrement;
						diff += 2 * dx - 2 * dy;
					}
				}
			}
		}
	}

	private Vector3f lineFrom2Points(Vector3f p1, Vector3f p2) {
		return new Vector3f(p2.y - p1.y, -(p2.x - p1.x), p1.y * (p2.x - p1.x) - p1.x * (p2.y - p1.y));
	}

	private float distanceOfPointFromLine(Vector3f line, Vector2f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float distanceOfPointFromLine(Vector3f line, Vector3f p) {
		return line.get(0) * p.x + line.get(1) * p.y + line.get(2);
	}

	private float barycentricInterpolation_f(Vector3f barycentricCoordinates, float p1_property, float p2_property,
			float p3_property) {
		return barycentricCoordinates.get(0) * p1_property + barycentricCoordinates.get(1) * p2_property
				+ barycentricCoordinates.get(2) * p3_property;
	}

	private Vector2f barycentricInterpolation_v2(Vector3f barycentricCoordinates, Vector2f p1_property,
			Vector2f p2_property, Vector2f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

	private Vector3f barycentricInterpolation_v3(Vector3f barycentricCoordinates, Vector3f p1_property,
			Vector3f p2_property, Vector3f p3_property) {
		return p1_property.mul(barycentricCoordinates.get(0)).add(p2_property.mul(barycentricCoordinates.get(1)))
				.add(p3_property.mul(barycentricCoordinates.get(2)));
	}

//	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color, short[] p3_color, short[] interpolatedColor) {
//		interpolatedColor[0] = (short)((float)p1_color[0]*barycentricCoordinates.get(0) + (float)p2_color[0]*barycentricCoordinates.get(1) + (float)p3_color[0]*barycentricCoordinates.get(2)); 
//		interpolatedColor[1] = (short)((float)p1_color[1]*barycentricCoordinates.get(0) + (float)p2_color[1]*barycentricCoordinates.get(1) + (float)p3_color[1]*barycentricCoordinates.get(2)); 
//		interpolatedColor[2] = (short)((float)p1_color[2]*barycentricCoordinates.get(0) + (float)p2_color[2]*barycentricCoordinates.get(1) + (float)p3_color[2]*barycentricCoordinates.get(2));
//	}
	private void barycentricInterpolation_color(Vector3f barycentricCoordinates, short[] p1_color, short[] p2_color,
			short[] p3_color, short[] interpolatedColor) {
		interpolatedColor[0] = (short) Math.max(0, Math.min(255, (p1_color[0] * barycentricCoordinates.get(0)
				+ p2_color[0] * barycentricCoordinates.get(1) + p3_color[0] * barycentricCoordinates.get(2))));
		interpolatedColor[1] = (short) Math.max(0, Math.min(255, (p1_color[1] * barycentricCoordinates.get(0)
				+ p2_color[1] * barycentricCoordinates.get(1) + p3_color[1] * barycentricCoordinates.get(2))));
		interpolatedColor[2] = (short) Math.max(0, Math.min(255, (p1_color[2] * barycentricCoordinates.get(0)
				+ p2_color[2] * barycentricCoordinates.get(1) + p3_color[2] * barycentricCoordinates.get(2))));
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-09-25 11:30:28.862
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-09-25 11:30:28.863
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
